                                        PAGE    87
''      MACRO-80 3.44   09-Dec-81       PAGE    1


                                
                                ;       ORG             0E600H
                         C              INCLUDE incBDOS.MAC
                         C              PAGE
''      MACRO-80 3.44   09-Dec-81       PAGE    1-1


                         C      
                         C      ;       PN      BD08
                         C      ;****************************************************************
                         C      ;*               S  Y  S  4    --- Basisroutinen  (B D O S)     *
                         C      ;*                                 basic disc operating system  *
                         C      ;*                                 entspricht CP/M version 2.2  *
                         C      ;*  Version      -----------------------------------------------*
                         C      ;*               reassembliert: M. Herbote --- K EAW  ZFT (WFT) *
                         C      ;*  V 4 . 1      -----------------------------------------------*
                         C      ;*               Stand        : 20. Juli 1984                   *
                         C      ;*  V 4 . 2      -----------------------------------------------*
                         C      ;*               Geaenderte Label und eingefuegte Kommentare    *
                         C      ;*               Stand        :   . Juni 2024                   *
                         C      ;****************************************************************
                         C      
  0003                   C      IOBYTE   EQU     3                     ;i/o definition byte
  0080                   C      TBUFF    EQU     00080H                ;i/o buffer and command line storage
                         C      
                         C      ;  Dies sind Equates fC<r die verschiedenen ASCII-Zeichen
  0007                   C      BELL     EQU     07h
  0008                   C      BS       EQU     08h                   ;Backspace
  0009                   C      TAB      EQU     09h
  000A                   C      LF       EQU     0Ah
  000D                   C      CR       EQU     0Dh                   ;Carriage return
  000F                   C      FF       EQU     0FH                   ;Form Feed
  0003                   C      CTRLC    EQU     03h                   ;Dies ist CTRL-C
  0005                   C      CTRLE    EQU     05h                   ;Dies ist CTRL-E
  0010                   C      CTRLP    EQU     10h                   ;Dies ist CTRL-P
  0012                   C      CTRLR    EQU     12h                   ;Dies ist CTRL-R
  0013                   C      CTRLS    EQU     13h                   ;Dies ist CTRL-S
  0015                   C      CTRLU    EQU     15h                   ;Dies ist CTRL-U
  0018                   C      CTRLX    EQU     18h                   ;Dies ist CTRL-X
  001A                   C      CTRLZ    EQU     1Ah                   ;Dies ist CTRL-Z or EOF
  0020                   C      BLANK    EQU     ' '                   ;Leerzeichen
  003E                   C      PROMPT   EQU     '>'                   ;CCP Promptzeichen
  007F                   C      DEL      EQU     7Fh                   ;Delete  Code
                         C      
                         C               .PHASE  0E600H
  E600                   C      BDOS     EQU     $
  E600                   C               DEFS    6,0
                         C      
  E606                   C      FBASE:
  E606    C3 E611        C               JP      FBASE1
                         C      
  E609    E699           C      BADSCTR: DW      ERROR1                ;bad sector on read or write
  E60B    E6A5           C      BADSLCT: DW      ERROR2                ;bad disk select
  E60D    E6AB           C      RODISK:  DW      ERROR3                ;disk is read only
  E60F    E6B1           C      ROFILE:  DW      ERROR4                ;file is read only
                         C      
                         C      ;
                         C      ;   Entry into bdos. (DE) or (E) are the parameters passed
                         C      ;   The function number desired is in register (C)
                         C      ;
  E611                   C      FBASE1:
  E611    EB             C               EX      DE,HL                 ;save the (DE) parameters
  E612    22 E943        C               LD      (PARAMS),HL
  E615    EB             C               EX      DE,HL
  E616    7B             C               LD      A,E                   ;and save register (E) in particular
  E617    32 F3D6        C               LD      (EPARAM),A
  E61A    21 0000        C               LD      HL,0
  E61D    22 E945        C               LD      (STATUS),HL           ;clear return status
  E620    39             C               ADD     HL,SP
  E621    22 E90F        C               LD      (USRSTACK),HL         ;save users stack pointer
  E624    31 E941        C               LD      SP,STKAREA            ;and set our own
  E627    AF             C               XOR     A                     ;clear auto select storage space
  E628    32 F3E0        C               LD      (AUTOFLAG),A
  E62B    32 F3DE        C               LD      (AUTO),A
  E62E    21 F374        C               LD      HL,GOBACK             ;set return address
  E631    E5             C               PUSH    HL
  E632    79             C               LD      A,C                   ;get function number
  E633    FE 29          C               CP      NFUNCTS               ;valid function number?
  E635    D0             C               RET     NC
  E636    4B             C               LD      C,E                   ;keep single register function here
  E637    21 E647        C               LD      HL,FUNCTNS            ;now look thru the function table
  E63A    5F             C               LD      E,A
  E63B    16 00          C               LD      D,0                   ;(DE)=function number
  E63D    19             C               ADD     HL,DE
  E63E    19             C               ADD     HL,DE                 ;(HL)=(start of table)+2*(function number)
  E63F    5E             C               LD      E,(HL)
  E640    23             C               INC     HL
  E641    56             C               LD      D,(HL)                ;now (DE)=address for this function
  E642    2A E943        C               LD      HL,(PARAMS)           ;retrieve parameters
''      MACRO-80 3.44   09-Dec-81       PAGE    1-2


  E645    EB             C               EX      DE,HL                 ;now (DE) has the original parameters
  E646    E9             C               JP      (HL)                  ;execute desired function
                         C      
                         C               PAGE
''      MACRO-80 3.44   09-Dec-81       PAGE    1-3


                         C      
                         C      ;
                         C      ;   BDOS function jump table
                         C      ;
  0029                   C      NFUNCTS  EQU     41                    ;number of functions in followin table
                         C      ;
  E647                   C      FUNCTNS:
  E647    F403           C               DW      WBOOT
  E649    E8C8           C               DW      GETCON
  E64B    E790           C               DW      OUTCON
  E64D    E8CE           C               DW      GETRDR
  E64F    F412           C               DW      PUNCH
  E651    F40F           C               DW      LIST
  E653    E8D4           C               DW      DIRCIO
  E655    E8ED           C               DW      GETIOB
  E657    E8F3           C               DW      SETIOB
  E659    E8F8           C               DW      PRTSTR
  E65B    E7E1           C               DW      RDBUFF
  E65D    E8FE           C               DW      GETCSTS
  E65F    F27E           C               DW      GETVER
  E661    F283           C               DW      RSTDSK
  E663    F245           C               DW      SETDSK
  E665    F29C           C               DW      OPENFIL
  E667    F2A5           C               DW      CLOSEFIL
  E669    F2AB           C               DW      GETFST
  E66B    F2C8           C               DW      GETNXT
  E66D    F2D7           C               DW      DELFILE
  E66F    F2E0           C               DW      READSEQ
  E671    F2E6           C               DW      WRTSEQ
  E673    F2EC           C               DW      FCREATE
  E675    F2F5           C               DW      RENFILE
  E677    F2FE           C               DW      GETLOG
  E679    F304           C               DW      GETCRNT
  E67B    F30A           C               DW      PUTDMA
  E67D    F311           C               DW      GETALOC
  E67F    EB2C           C               DW      WRTPRTD
  E681    F317           C               DW      GETROV
  E683    F31D           C               DW      SETATTR
  E685    F326           C               DW      GETPARM
  E687    F32D           C               DW      GETUSER
  E689    F341           C               DW      RDRANDOM
  E68B    F347           C               DW      WTRANDOM
  E68D    F34D           C               DW      FILESIZE
  E68F    F20E           C               DW      SETRAN
  E691    F353           C               DW      LOGOFF
  E693    E904           C               DW      RTN
  E695    E904           C               DW      RTN
  E697    F39B           C               DW      WTSPECL
                         C      
                         C               PAGE
''      MACRO-80 3.44   09-Dec-81       PAGE    1-4


                         C      
                         C      ;
                         C      ;   Bdos error message section.
                         C      ;
  E699                   C      ERROR1:
  E699    21 E6CA        C               LD      HL,BADSEC             ;bad sector message
  E69C    CD E6E5        C               CALL    PRTERR                ;print it and get a 1 char responce
  E69F    FE 03          C               CP      CTRLC                 ;re-boot request (control-c)?
  E6A1    CA 0000        C               JP      Z,0                   ;yes
  E6A4    C9             C               RET                           ;no, return to retry i/o function
                         C      ;
  E6A5                   C      ERROR2:
  E6A5    21 E6D5        C               LD      HL,BADSEL             ;bad drive selected
  E6A8    C3 E6B4        C               JP      ERROR5
                         C      ;
  E6AB                   C      ERROR3:
  E6AB    21 E6E1        C               LD      HL,DISKRO             ;disk is read only
  E6AE    C3 E6B4        C               JP      ERROR5
                         C      ;
  E6B1                   C      ERROR4:
  E6B1    21 E6DC        C               LD      HL,FILERO             ;file is read only
  E6B4                   C      ERROR5:
  E6B4    CD E6E5        C               CALL    PRTERR
  E6B7    C3 0000        C               JP      0                     ;always reboot on these errors
                         C      ;
  E6BA    42 64 6F 73    C      BDOSERR: DB      'Bdos Err On '
  E6BE    20 45 72 72    C      
  E6C2    20 4F 6E 20    C      
  E6C6    20 3A 20 24    C      BDOSDRV: DB      ' : $'
  E6CA    42 61 64 20    C      BADSEC:  DB      'Bad Sector$'
  E6CE    53 65 63 74    C      
  E6D2    6F 72 24       C      
  E6D5    53 65 6C 65    C      BADSEL:  DB      'Select$'
  E6D9    63 74 24       C      
  E6DC    46 69 6C 65    C      FILERO:  DB      'File '
  E6E0    20             C      
  E6E1    52 2F 4F 24    C      DISKRO:  DB      'R/O$'
                         C      
                         C      ;
                         C      ;   Print bdos error message
                         C      ;
  E6E5                   C      PRTERR:
  E6E5    E5             C               PUSH    HL                    ;save second message pointer
  E6E6    CD E7C9        C               CALL    OUTCRLF               ;send (cr)(lf)
  E6E9    3A E942        C               LD      A,(ACTIVE)            ;get active drive
  E6EC    C6 41          C               ADD     A,'A'                 ;make ascii
  E6EE    32 E6C6        C               LD      (BDOSDRV),A           ;and put in message
  E6F1    01 E6BA        C               LD      BC,BDOSERR            ;and print it
  E6F4    CD E7D3        C               CALL    PRTMESG
  E6F7    C1             C               POP     BC                    ;print second message line now
  E6F8    CD E7D3        C               CALL    PRTMESG
                         C      
                         C      ;
                         C      ;   Get an input character. We will check our 1 character buffer first
                         C      ;   This may be set by the console status routine
                         C      ;
  E6FB                   C      GETCHAR:
  E6FB    21 E90E        C               LD      HL,CHARBUF            ;check character buffer
  E6FE    7E             C               LD      A,(HL)                ;anything present already?
  E6FF    36 00          C               LD      (HL),0                ;...either case clear it
  E701    B7             C               OR      A
  E702    C0             C               RET     NZ                    ;yes, use it
  E703    C3 F409        C               JP      CONIN                 ;nope, go get a character responce
                         C      
                         C      ;
                         C      ;   Input and echo a character.
                         C      ;
  E706                   C      GETECHO:
  E706    CD E6FB        C               CALL    GETCHAR               ;input a character
  E709    CD E714        C               CALL    CHKCHAR               ;carriage control?
  E70C    D8             C               RET     C                     ;no, a regular control char so don't echo
  E70D    F5             C               PUSH    AF                    ;ok, save character now
  E70E    4F             C               LD      C,A
  E70F    CD E790        C               CALL    OUTCON                ;and echo it
  E712    F1             C               POP     AF                    ;get character and return
  E713    C9             C               RET
                         C      
                         C      ;
                         C      ;   Check character in (A)
                         C      ;   Set the zero flag on a carriage control character and the carry flag on any other control character
                         C      ;
  E714                   C      CHKCHAR:
''      MACRO-80 3.44   09-Dec-81       PAGE    1-5


  E714    FE 0D          C               CP      CR                    ;check for carriage return, line feed, backspace
  E716    C8             C               RET     Z                     ;or a tab
  E717    FE 0A          C               CP      LF
  E719    C8             C               RET     Z
  E71A    FE 09          C               CP      TAB
  E71C    C8             C               RET     Z
  E71D    FE 08          C               CP      BS
  E71F    C8             C               RET     Z
  E720    FE 20          C               CP      BLANK                 ;other control char? Set carry flag
  E722    C9             C               RET
                         C      
                         C      ;
                         C      ;   Check the console during output
                         C      ;   Halt on a control-s, then reboot on a control-c
                         C      ;   If anything else is ready, clear the zero flag and return (the calling routine may want to do something)
                         C      ;
  E723                   C      CKCONSOL:
  E723    3A E90E        C               LD      A,(CHARBUF)           ;check buffer
  E726    B7             C               OR      A                     ;if anything, just return without checking
  E727    C2 E745        C               JP      NZ,CKCON2
  E72A    CD F406        C               CALL    CONST                 ;nothing in buffer. Check console
  E72D    E6 01          C               AND     001H                  ;look at bit 0
  E72F    C8             C               RET     Z                     ;return if nothing
  E730    CD F409        C               CALL    CONIN                 ;ok, get it
  E733    FE 13          C               CP      CTRLS                 ;if not control-s, return with zero cleared
  E735    C2 E742        C               JP      NZ,CKCON1
  E738    CD F409        C               CALL    CONIN                 ;halt processing until another char
  E73B    FE 03          C               CP      CTRLC                 ;is typed. Control-c?
  E73D    CA 0000        C               JP      Z,0                   ;yes, reboot now
  E740    AF             C               XOR     A                     ;no, just pretend nothing was ever ready
  E741    C9             C               RET
  E742                   C      CKCON1:
  E742    32 E90E        C               LD      (CHARBUF),A           ;save character in buffer for later processing
  E745                   C      CKCON2:
  E745    3E 01          C               LD      A,1                   ;set (A) to non zero to mean something is ready
  E747    C9             C               RET
                         C      
                         C      ;
                         C      ;   Output (C) to the screen
                         C      ;   If the printer flip-flop flag is set, we will send character to printer also
                         C      ;   The console will be checked in the process
                         C      ;
  E748                   C      OUTCHAR:
  E748    3A E90A        C               LD      A,(OUTFLAG)           ;check output flag
  E74B    B7             C               OR      A                     ;anything and we won't generate output
  E74C    C2 E762        C               JP      NZ,OUTCHR1
  E74F    C5             C               PUSH    BC
  E750    CD E723        C               CALL    CKCONSOL              ;check console (we don't care whats there)
  E753    C1             C               POP     BC
  E754    C5             C               PUSH    BC
  E755    CD F40C        C               CALL    CONOUT                ;output (C) to the screen
  E758    C1             C               POP     BC
  E759    C5             C               PUSH    BC
  E75A    3A E90D        C               LD      A,(PRTFLAG)           ;check printer flip-flop flag
  E75D    B7             C               OR      A
  E75E    C4 F40F        C               CALL    NZ,LIST               ;print it also if non-zero
  E761    C1             C               POP     BC
  E762                   C      OUTCHR1:
  E762    79             C               LD      A,C                   ;update cursors position
  E763    21 E90C        C               LD      HL,CURPOS
  E766    FE 7F          C               CP      DEL                   ;rubouts don't do anything here
  E768    C8             C               RET     Z
  E769    34             C               INC     (HL)                  ;bump line pointer
  E76A    FE 20          C               CP      BLANK                 ;and return if a normal character
  E76C    D0             C               RET     NC
  E76D    35             C               DEC     (HL)                  ;restore and check for the start of the line
  E76E    7E             C               LD      A,(HL)
  E76F    B7             C               OR      A
  E770    C8             C               RET     Z                     ;ingnore control characters at the start of the line
  E771    79             C               LD      A,C
  E772    FE 08          C               CP      BS                    ;is it a backspace?
  E774    C2 E779        C               JP      NZ,OUTCHR2
  E777    35             C               DEC     (HL)                  ;yes, backup pointer
  E778    C9             C               RET
  E779                   C      OUTCHR2:
  E779    FE 0A          C               CP      LF                    ;is it a line feed?
  E77B    C0             C               RET     NZ                    ;ignore anything else
  E77C    36 00          C               LD      (HL),0                ;reset pointer to start of line
  E77E    C9             C               RET
                         C      
                         C      ;
                         C      ;   Output (A) to the screen
                         C      ;   If it is a control character (other than carriage control), use ^x format
''      MACRO-80 3.44   09-Dec-81       PAGE    1-6


                         C      ;
  E77F                   C      SHOWIT:
  E77F    79             C               LD      A,C
  E780    CD E714        C               CALL    CHKCHAR               ;check character
  E783    D2 E790        C               JP      NC,OUTCON             ;not a control, use normal output
  E786    F5             C               PUSH    AF
  E787    0E 5E          C               LD      C,'^'                 ;for a control character, preceed it with '^'
  E789    CD E748        C               CALL    OUTCHAR
  E78C    F1             C               POP     AF
  E78D    F6 40          C               OR      '@'                   ;and then use the letter equivelant
  E78F    4F             C               LD      C,A
                         C      ;
                         C      ;   Function to output (C) to the console device and expand tabs if necessary
                         C      ;
  E790                   C      OUTCON:
  E790    79             C               LD      A,C
  E791    FE 09          C               CP      TAB                   ;is it a tab?
  E793    C2 E748        C               JP      NZ,OUTCHAR            ;use regular output
  E796                   C      OUTCON1:
  E796    0E 20          C               LD      C,BLANK               ;yes it is, use spaces instead
  E798    CD E748        C               CALL    OUTCHAR
  E79B    3A E90C        C               LD      A,(CURPOS)            ;go until the cursor is at a multiple of 8
  E79E    E6 07          C               AND     007H                  ;position
  E7A0    C2 E796        C               JP      NZ,OUTCON1
  E7A3    C9             C               RET
                         C      
                         C      ;
                         C      ;   Echo a backspace character. Erase the prevoius character on the screen
                         C      ;
  E7A4                   C      BACKUP:
  E7A4    CD E7AC        C               CALL    BACKUP1               ;backup the screen 1 place
  E7A7    0E 20          C               LD      C,BLANK               ;then blank that character
  E7A9    CD F40C        C               CALL    CONOUT
  E7AC                   C      BACKUP1:
  E7AC    0E 08          C               LD      C,BS                  ;then back space once more
  E7AE    C3 F40C        C               JP      CONOUT
                         C      
                         C      ;
                         C      ;   Signal a deleted line. Print a '#' at the end and start over
                         C      ;
  E7B1                   C      NEWLINE:
  E7B1    0E 23          C               LD      C,'#'
  E7B3    CD E748        C               CALL    OUTCHAR               ;print this
  E7B6    CD E7C9        C               CALL    OUTCRLF               ;start new line
  E7B9                   C      NEWLN1:
  E7B9    3A E90C        C               LD      A,(CURPOS)            ;move the cursor to the starting position
  E7BC    21 E90B        C               LD      HL,STARTING
  E7BF    BE             C               CP      (HL)
  E7C0    D0             C               RET     NC                    ;there yet?
  E7C1    0E 20          C               LD      C,BLANK
  E7C3    CD E748        C               CALL    OUTCHAR               ;nope, keep going
  E7C6    C3 E7B9        C               JP      NEWLN1
                         C      
                         C      ;
                         C      ;   Output a (cr) (lf) to the console device (screen)
                         C      ;
  E7C9                   C      OUTCRLF:
  E7C9    0E 0D          C               LD      C,CR
  E7CB    CD E748        C               CALL    OUTCHAR
  E7CE    0E 0A          C               LD      C,LF
  E7D0    C3 E748        C               JP      OUTCHAR
                         C      
                         C      ;
                         C      ;   Print message pointed to by (BC). It will end with a '$'
                         C      ;
  E7D3                   C      PRTMESG:
  E7D3    0A             C               LD      A,(BC)                ;check for terminating character
  E7D4    FE 24          C               CP      '$'
  E7D6    C8             C               RET     Z
  E7D7    03             C               INC     BC
  E7D8    C5             C               PUSH    BC                    ;otherwise, bump pointer and print it
  E7D9    4F             C               LD      C,A
  E7DA    CD E790        C               CALL    OUTCON
  E7DD    C1             C               POP     BC
  E7DE    C3 E7D3        C               JP      PRTMESG
                         C      
                         C               PAGE
''      MACRO-80 3.44   09-Dec-81       PAGE    1-7


                         C      
                         C      ;
                         C      ;   Function to execute a buffered read.
                         C      ;
  E7E1                   C      RDBUFF:
  E7E1    3A E90C        C               LD      A,(CURPOS)            ;use present location as starting one
  E7E4    32 E90B        C               LD      (STARTING),A
  E7E7    2A E943        C               LD      HL,(PARAMS)           ;get the maximum buffer space
  E7EA    4E             C               LD      C,(HL)
  E7EB    23             C               INC     HL                    ;point to first available space
  E7EC    E5             C               PUSH    HL                    ;and save
  E7ED    06 00          C               LD      B,0                   ;keep a character count
  E7EF                   C      RDBUF1:
  E7EF    C5             C               PUSH    BC
  E7F0    E5             C               PUSH    HL
  E7F1                   C      RDBUF2:
  E7F1    CD E6FB        C               CALL    GETCHAR               ;get the next input character
  E7F4    E6 7F          C               AND     07FH                  ;strip bit 7
  E7F6    E1             C               POP     HL                    ;reset registers
  E7F7    C1             C               POP     BC
  E7F8    FE 0D          C               CP      CR                    ;end of the line?
  E7FA    CA E8C1        C               JP      Z,RDBUF17
  E7FD    FE 0A          C               CP      LF
  E7FF    CA E8C1        C               JP      Z,RDBUF17
  E802    FE 08          C               CP      BS                    ;how about a backspace?
  E804    C2 E816        C               JP      NZ,RDBUF3
  E807    78             C               LD      A,B                   ;yes, but ignore at the beginning of the line
  E808    B7             C               OR      A
  E809    CA E7EF        C               JP      Z,RDBUF1
  E80C    05             C               DEC     B                     ;ok, update counter
  E80D    3A E90C        C               LD      A,(CURPOS)            ;if we backspace to the start of the line
  E810    32 E90A        C               LD      (OUTFLAG),A           ;treat as a cancel (control-x)
  E813    C3 E870        C               JP      RDBUF10
  E816                   C      RDBUF3:
  E816    FE 7F          C               CP      DEL                   ;user typed a rubout?
  E818    C2 E826        C               JP      NZ,RDBUF4
  E81B    78             C               LD      A,B                   ;ignore at the start of the line
  E81C    B7             C               OR      A
  E81D    CA E7EF        C               JP      Z,RDBUF1
  E820    7E             C               LD      A,(HL)                ;ok, echo the prevoius character
  E821    05             C               DEC     B                     ;and reset pointers (counters)
  E822    2B             C               DEC     HL
  E823    C3 E8A9        C               JP      RDBUF15
  E826                   C      RDBUF4:
  E826    FE 05          C               CP      CTRLE                 ;physical end of line?
  E828    C2 E837        C               JP      NZ,RDBUF5
  E82B    C5             C               PUSH    BC                    ;yes, do it
  E82C    E5             C               PUSH    HL
  E82D    CD E7C9        C               CALL    OUTCRLF
  E830    AF             C               XOR     A                     ;and update starting position
  E831    32 E90B        C               LD      (STARTING),A
  E834    C3 E7F1        C               JP      RDBUF2
  E837                   C      RDBUF5:
  E837    FE 10          C               CP      CTRLP                 ;control-p?
  E839    C2 E848        C               JP      NZ,RDBUF6
  E83C    E5             C               PUSH    HL                    ;yes, flip the print flag filp-flop byte
  E83D    21 E90D        C               LD      HL,PRTFLAG
  E840    3E 01          C               LD      A,1                   ;PRTFLAG=1-PRTFLAG
  E842    96             C               SUB     (HL)
  E843    77             C               LD      (HL),A
  E844    E1             C               POP     HL
  E845    C3 E7EF        C               JP      RDBUF1
  E848                   C      RDBUF6:
  E848    FE 18          C               CP      CTRLX                 ;control-x (cancel)?
  E84A    C2 E85F        C               JP      NZ,RDBUF8
  E84D    E1             C               POP     HL
  E84E                   C      RDBUF7:
  E84E    3A E90B        C               LD      A,(STARTING)          ;yes, backup the cursor to here
  E851    21 E90C        C               LD      HL,CURPOS
  E854    BE             C               CP      (HL)
  E855    D2 E7E1        C               JP      NC,RDBUFF             ;done yet?
  E858    35             C               DEC     (HL)                  ;no, decrement pointer and output back up one space
  E859    CD E7A4        C               CALL    BACKUP
  E85C    C3 E84E        C               JP      RDBUF7
  E85F                   C      RDBUF8:
  E85F    FE 15          C               CP      CTRLU                 ;cntrol-u (cancel line)?
  E861    C2 E86B        C               JP      NZ,RDBUF9
  E864    CD E7B1        C               CALL    NEWLINE               ;start a new line
  E867    E1             C               POP     HL
  E868    C3 E7E1        C               JP      RDBUFF
  E86B                   C      RDBUF9:
  E86B    FE 12          C               CP      CTRLR                 ;control-r?
''      MACRO-80 3.44   09-Dec-81       PAGE    1-8


  E86D    C2 E8A6        C               JP      NZ,RDBUF14
  E870                   C      RDBUF10:
  E870    C5             C               PUSH    BC                    ;yes, start a new line and retype the old one
  E871    CD E7B1        C               CALL    NEWLINE
  E874    C1             C               POP     BC
  E875    E1             C               POP     HL
  E876    E5             C               PUSH    HL
  E877    C5             C               PUSH    BC
  E878                   C      RDBUF11:
  E878    78             C               LD      A,B                   ;done whole line yet?
  E879    B7             C               OR      A
  E87A    CA E88A        C               JP      Z,RDBUF12
  E87D    23             C               INC     HL                    ;nope, get next character
  E87E    4E             C               LD      C,(HL)
  E87F    05             C               DEC     B                     ;count it
  E880    C5             C               PUSH    BC
  E881    E5             C               PUSH    HL
  E882    CD E77F        C               CALL    SHOWIT                ;and display it
  E885    E1             C               POP     HL
  E886    C1             C               POP     BC
  E887    C3 E878        C               JP      RDBUF11
  E88A                   C      RDBUF12:
  E88A    E5             C               PUSH    HL                    ;done with line. If we were displaying
  E88B    3A E90A        C               LD      A,(OUTFLAG)           ;then update cursor position
  E88E    B7             C               OR      A
  E88F    CA E7F1        C               JP      Z,RDBUF2
  E892    21 E90C        C               LD      HL,CURPOS             ;because this line is shorter, we must
  E895    96             C               SUB     (HL)                  ;back up the cursor (not the screen however)
  E896    32 E90A        C               LD      (OUTFLAG),A           ;some number of positions
  E899                   C      RDBUF13:
  E899    CD E7A4        C               CALL    BACKUP                ;note that as long as (OUTFLAG) is non
  E89C    21 E90A        C               LD      HL,OUTFLAG            ;zero, the screen will not be changed
  E89F    35             C               DEC     (HL)
  E8A0    C2 E899        C               JP      NZ,RDBUF13
  E8A3    C3 E7F1        C               JP      RDBUF2                ;now just get the next character
                         C      ;
                         C      ;   Just a normal character, put this in our buffer and echo
                         C      ;
  E8A6                   C      RDBUF14:
  E8A6    23             C               INC     HL
  E8A7    77             C               LD      (HL),A                ;store character
  E8A8    04             C               INC     B                     ;and count it
  E8A9                   C      RDBUF15:
  E8A9    C5             C               PUSH    BC
  E8AA    E5             C               PUSH    HL
  E8AB    4F             C               LD      C,A                   ;echo it now
  E8AC    CD E77F        C               CALL    SHOWIT
  E8AF    E1             C               POP     HL
  E8B0    C1             C               POP     BC
  E8B1    7E             C               LD      A,(HL)                ;was it an abort request?
  E8B2    FE 03          C               CP      CTRLC                 ;control-c abort?
  E8B4    78             C               LD      A,B
  E8B5    C2 E8BD        C               JP      NZ,RDBUF16
  E8B8    FE 01          C               CP      1                     ;only if at start of line
  E8BA    CA 0000        C               JP      Z,0
  E8BD                   C      RDBUF16:
  E8BD    B9             C               CP      C                     ;nope, have we filled the buffer?
  E8BE    DA E7EF        C               JP      C,RDBUF1
  E8C1                   C      RDBUF17:
  E8C1    E1             C               POP     HL                    ;yes end the line and return
  E8C2    70             C               LD      (HL),B
  E8C3    0E 0D          C               LD      C,00DH
  E8C5    C3 E748        C               JP      OUTCHAR               ;output (cr) and return
                         C      
                         C               PAGE
''      MACRO-80 3.44   09-Dec-81       PAGE    1-9


                         C      
                         C      ;
                         C      ;   Function to get a character from the console device
                         C      ;
  E8C8                   C      GETCON:
  E8C8    CD E706        C               CALL    GETECHO               ;get and echo
  E8CB    C3 E901        C               JP      SETSTAT               ;set status and return
                         C      
                         C      ;
                         C      ;   Function to get a character from the tape reader device
                         C      ;
  E8CE                   C      GETRDR:
  E8CE    CD F415        C               CALL    READER                ;get a character from reader
  E8D1    C3 E901        C               JP      SETSTAT               ;set status and return
                         C      
                         C      ;
                         C      ;   Function to perform direct console i/o
                         C      ;   If (C) contains (FF) then this is an input request
                         C      ;   If (C) contains (FE) then this is a status request
                         C      ;   Otherwise we are to output (C).
                         C      ;
  E8D4                   C      DIRCIO:
  E8D4    79             C               LD      A,C                   ;test for (FF)
  E8D5    3C             C               INC     A
  E8D6    CA E8E0        C               JP      Z,DIRC1
  E8D9    3C             C               INC     A                     ;test for (FE)
  E8DA    CA F406        C               JP      Z,CONST
  E8DD    C3 F40C        C               JP      CONOUT                ;just output (C)
  E8E0                   C      DIRC1:
  E8E0    CD F406        C               CALL    CONST                 ;this is an input request
  E8E3    B7             C               OR      A
  E8E4    CA F391        C               JP      Z,GOBACK1             ;not ready? Just return (directly)
  E8E7    CD F409        C               CALL    CONIN                 ;yes, get character
  E8EA    C3 E901        C               JP      SETSTAT               ;set status and return
                         C      
                         C      ;
                         C      ;   Function to return the i/o byte
                         C      ;
  E8ED                   C      GETIOB:
  E8ED    3A 0003        C               LD      A,(IOBYTE)
  E8F0    C3 E901        C               JP      SETSTAT
                         C      
                         C      ;
                         C      ;   Function to set the i/o byte
                         C      ;
  E8F3                   C      SETIOB:
  E8F3    21 0003        C               LD      HL,IOBYTE
  E8F6    71             C               LD      (HL),C
  E8F7    C9             C               RET
                         C      
                         C      ;
                         C      ;   Function to print the character string pointed to by (DE) on the console device
                         C      ;   The string ends with a '$'
                         C      ;
  E8F8                   C      PRTSTR:
  E8F8    EB             C               EX      DE,HL
  E8F9    4D             C               LD      C,L
  E8FA    44             C               LD      B,H                   ;now (BC) points to it
  E8FB    C3 E7D3        C               JP      PRTMESG
                         C      
                         C      ;
                         C      ;   Function to interigate the console device
                         C      ;
  E8FE                   C      GETCSTS:
  E8FE    CD E723        C               CALL    CKCONSOL
                         C      ;
                         C      ;   Get here to set the status and return to the cleanup section
                         C      ;   Then back to the user
                         C      ;
  E901                   C      SETSTAT:
  E901    32 E945        C               LD      (STATUS),A
  E904                   C      RTN:
  E904    C9             C               RET
                         C      
                         C      ;
                         C      ;   Set the status to 1 (read or write error code)
                         C      ;
  E905                   C      IOERR1:
  E905    3E 01          C               LD      A,1
  E907    C3 E901        C               JP      SETSTAT
                         C      
                         C               PAGE
''      MACRO-80 3.44   09-Dec-81       PAGE    1-10


                         C      
  E90A    00             C      OUTFLAG: DB      0                     ;output flag (non zero means no output)
  E90B    02             C      STARTING:DB      2                     ;starting position for cursor
  E90C    00             C      CURPOS:  DB      0                     ;cursor position (0=start of line)
  E90D    00             C      PRTFLAG: DB      0                     ;printer flag (control-p toggle). List if non zero
  E90E    00             C      CHARBUF: DB      0                     ;single input character buffer
                         C      
                         C      ;
                         C      ;   Stack area for BDOS calls.
                         C      ;
  E90F    0000           C      USRSTACK:DW      0                     ;save users stack pointer here
                         C      ;
  E911    00 00 00 00    C               DB      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  E915    00 00 00 00    C      
  E919    00 00 00 00    C      
  E91D    00 00 00 00    C      
  E921    00 00 00 00    C      
  E925    00 00 00 00    C      
  E929    00 00 00 00    C               DB      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  E92D    00 00 00 00    C      
  E931    00 00 00 00    C      
  E935    00 00 00 00    C      
  E939    00 00 00 00    C      
  E93D    00 00 00 00    C      
  E941                   C      STKAREA  EQU     $                     ;end of stack area
                         C      
  E941    00             C      USERNO:  DB      0                     ;current user number
  E942    00             C      ACTIVE:  DB      0                     ;currently active drive
  E943    0000           C      PARAMS:  DW      0                     ;save (DE) parameters here on entry
  E945    0000           C      STATUS:  DW      0                     ;status returned from bdos function
                         C      
                         C               PAGE
''      MACRO-80 3.44   09-Dec-81       PAGE    1-11


                         C      
                         C      ;
                         C      ;   Select error occured, jump to error routine
                         C      ;
  E947                   C      SLCTERR:
  E947    21 E60B        C               LD      HL,BADSLCT
                         C      ;
                         C      ;   Jump to (HL) indirectly
                         C      ;
  E94A                   C      JUMPHL:
  E94A    5E             C               LD      E,(HL)
  E94B    23             C               INC     HL
  E94C    56             C               LD      D,(HL)                ;now (DE) contain the desired address
  E94D    EB             C               EX      DE,HL
  E94E    E9             C               JP      (HL)
                         C      
                         C      ;
                         C      ;   Block move. (DE) to (HL), (C) bytes total
                         C      ;
  E94F                   C      DE2HL:
  E94F    0C             C               INC     C                     ;is count down to zero?
  E950                   C      DE2HL1:
  E950    0D             C               DEC     C
  E951    C8             C               RET     Z                     ;yes, we are done
  E952    1A             C               LD      A,(DE)                ;no, move one more byte
  E953    77             C               LD      (HL),A
  E954    13             C               INC     DE
  E955    23             C               INC     HL
  E956    C3 E950        C               JP      DE2HL1                ;and repeat
                         C      
                         C      ;
                         C      ;   Select the desired drive
                         C      ;
  E959                   C      SELECT:
  E959    3A E942        C               LD      A,(ACTIVE)            ;get active disk
  E95C    4F             C               LD      C,A
  E95D    CD F41B        C               CALL    SELDSK                ;select it
  E960    7C             C               LD      A,H                   ;valid drive?
  E961    B5             C               OR      L                     ;valid drive?
  E962    C8             C               RET     Z                     ;return if not
                         C      ;
                         C      ;   Here, the BIOS returned the address of the parameter block in (HL)
                         C      ;   We will extract the necessary pointers and save them
                         C      ;
  E963    5E             C               LD      E,(HL)                ;yes, get address of translation table into (DE)
  E964    23             C               INC     HL
  E965    56             C               LD      D,(HL)
  E966    23             C               INC     HL
  E967    22 F3B3        C               LD      (SCRATCH1),HL         ;save pointers to scratch areas
  E96A    23             C               INC     HL
  E96B    23             C               INC     HL
  E96C    22 F3B5        C               LD      (SCRATCH2),HL         ;ditto
  E96F    23             C               INC     HL
  E970    23             C               INC     HL
  E971    22 F3B7        C               LD      (SCRATCH3),HL         ;ditto
  E974    23             C               INC     HL
  E975    23             C               INC     HL
  E976    EB             C               EX      DE,HL                 ;now save the translation table address
  E977    22 F3D0        C               LD      (XLATE),HL
  E97A    21 F3B9        C               LD      HL,DIRBUF             ;put the next 8 bytes here
  E97D    0E 08          C               LD      C,8                   ;they consist of the directory buffer
  E97F    CD E94F        C               CALL    DE2HL                 ;pointer, parameter block pointer
  E982    2A F3BB        C               LD      HL,(DISKPB)           ;check and allocation vectors
  E985    EB             C               EX      DE,HL
  E986    21 F3C1        C               LD      HL,SECTORS            ;move parameter block into our ram
  E989    0E 0F          C               LD      C,15                  ;it is 15 bytes long
  E98B    CD E94F        C               CALL    DE2HL
  E98E    2A F3C6        C               LD      HL,(DSKSIZE)          ;check disk size
  E991    7C             C               LD      A,H                   ;more than 256 blocks on this?
  E992    21 F3DD        C               LD      HL,BIGDISK
  E995    36 FF          C               LD      (HL),0FFH             ;set to samll
  E997    B7             C               OR      A
  E998    CA E99D        C               JP      Z,SELECT1
  E99B    36 00          C               LD      (HL),0                ;wrong, set to large
  E99D                   C      SELECT1:
  E99D    3E FF          C               LD      A,0FFH                ;clear the zero flag
  E99F    B7             C               OR      A
  E9A0    C9             C               RET
                         C      
                         C      ;
                         C      ;   Routine to home the disk track head and clear pointers
                         C      ;
''      MACRO-80 3.44   09-Dec-81       PAGE    1-12


  E9A1                   C      HOMEDRV:
  E9A1    CD F418        C               CALL    HOME                  ;home the head
  E9A4    AF             C               XOR     A
  E9A5    2A F3B5        C               LD      HL,(SCRATCH2)         ;set our track pointer also
  E9A8    77             C               LD      (HL),A
  E9A9    23             C               INC     HL
  E9AA    77             C               LD      (HL),A
  E9AB    2A F3B7        C               LD      HL,(SCRATCH3)         ;and our sector pointer
  E9AE    77             C               LD      (HL),A
  E9AF    23             C               INC     HL
  E9B0    77             C               LD      (HL),A
  E9B1    C9             C               RET
                         C      
                         C      ;
                         C      ;   Do the actual disk read and check the error return status
                         C      ;
  E9B2                   C      DOREAD:
  E9B2    CD F427        C               CALL    READ
  E9B5    C3 E9BB        C               JP      IORET
                         C      ;
                         C      ;   Do the actual disk write and handle any bios error
                         C      ;
  E9B8                   C      DOWRITE:
  E9B8    CD F42A        C               CALL    WRITE
  E9BB                   C      IORET:
  E9BB    B7             C               OR      A
  E9BC    C8             C               RET     Z                     ;return unless an error occured
  E9BD    21 E609        C               LD      HL,BADSCTR            ;bad read/write on this sector
  E9C0    C3 E94A        C               JP      JUMPHL
                         C      
                         C      ;
                         C      ;   Routine to select the track and sector that the desired block number falls in
                         C      ;
  E9C3                   C      TRKSEC:
  E9C3    2A F3EA        C               LD      HL,(FILEPOS)          ;get position of last accessed file
  E9C6    0E 02          C               LD      C,2                   ;in directory and compute sector #
  E9C8    CD EAEA        C               CALL    SHIFTR                ;sector #=file-position/4
  E9CB    22 F3E5        C               LD      (BLKNMBR),HL          ;save this as the block number of interest
  E9CE    22 F3EC        C               LD      (CKSUMTBL),HL         ;what's it doing here too?
                         C      ;
                         C      ;   if the sector number has already been set (BLKNMBR), enter at this point
                         C      ;
  E9D1                   C      TRKSEC1:
  E9D1    21 F3E5        C               LD      HL,BLKNMBR
  E9D4    4E             C               LD      C,(HL)                ;move sector number into (BC)
  E9D5    23             C               INC     HL
  E9D6    46             C               LD      B,(HL)
  E9D7    2A F3B7        C               LD      HL,(SCRATCH3)         ;get current sector number and
  E9DA    5E             C               LD      E,(HL)                ;move this into (DE)
  E9DB    23             C               INC     HL
  E9DC    56             C               LD      D,(HL)
  E9DD    2A F3B5        C               LD      HL,(SCRATCH2)         ;get current track number
  E9E0    7E             C               LD      A,(HL)                ;and this into (HL)
  E9E1    23             C               INC     HL
  E9E2    66             C               LD      H,(HL)
  E9E3    6F             C               LD      L,A
  E9E4                   C      TRKSEC2:
  E9E4    79             C               LD      A,C                   ;is desired sector before current one?
  E9E5    93             C               SUB     E
  E9E6    78             C               LD      A,B
  E9E7    9A             C               SBC     A,D
  E9E8    D2 E9FA        C               JP      NC,TRKSEC3
  E9EB    E5             C               PUSH    HL                    ;yes, decrement sectors by one track
  E9EC    2A F3C1        C               LD      HL,(SECTORS)          ;get sectors per track
  E9EF    7B             C               LD      A,E
  E9F0    95             C               SUB     L
  E9F1    5F             C               LD      E,A
  E9F2    7A             C               LD      A,D
  E9F3    9C             C               SBC     A,H
  E9F4    57             C               LD      D,A                   ;now we have backed up one full track
  E9F5    E1             C               POP     HL
  E9F6    2B             C               DEC     HL                    ;adjust track counter
  E9F7    C3 E9E4        C               JP      TRKSEC2
  E9FA                   C      TRKSEC3:
  E9FA    E5             C               PUSH    HL                    ;desired sector is after current one
  E9FB    2A F3C1        C               LD      HL,(SECTORS)          ;get sectors per track
  E9FE    19             C               ADD     HL,DE                 ;bump sector pointer to next track
  E9FF    DA EA0F        C               JP      C,TRKSEC4
  EA02    79             C               LD      A,C                   ;is desired sector now before current one?
  EA03    95             C               SUB     L
  EA04    78             C               LD      A,B
  EA05    9C             C               SBC     A,H
  EA06    DA EA0F        C               JP      C,TRKSEC4
''      MACRO-80 3.44   09-Dec-81       PAGE    1-13


  EA09    EB             C               EX      DE,HL                 ;not yes, increment track counter
  EA0A    E1             C               POP     HL                    ;and continue until it is
  EA0B    23             C               INC     HL
  EA0C    C3 E9FA        C               JP      TRKSEC3
                         C      ;
                         C      ;   here we have determined the track number that contains the desired sector
                         C      ;
  EA0F                   C      TRKSEC4:
  EA0F    E1             C               POP     HL                    ;get track number (HL)
  EA10    C5             C               PUSH    BC
  EA11    D5             C               PUSH    DE
  EA12    E5             C               PUSH    HL
  EA13    EB             C               EX      DE,HL
  EA14    2A F3CE        C               LD      HL,(OFFSET)           ;adjust for first track offset
  EA17    19             C               ADD     HL,DE
  EA18    44             C               LD      B,H
  EA19    4D             C               LD      C,L
  EA1A    CD F41E        C               CALL    SETTRK                ;select this track
  EA1D    D1             C               POP     DE                    ;reset current track pointer
  EA1E    2A F3B5        C               LD      HL,(SCRATCH2)
  EA21    73             C               LD      (HL),E
  EA22    23             C               INC     HL
  EA23    72             C               LD      (HL),D
  EA24    D1             C               POP     DE
  EA25    2A F3B7        C               LD      HL,(SCRATCH3)         ;reset the first sector on this track
  EA28    73             C               LD      (HL),E
  EA29    23             C               INC     HL
  EA2A    72             C               LD      (HL),D
  EA2B    C1             C               POP     BC
  EA2C    79             C               LD      A,C                   ;now subtract the desired one
  EA2D    93             C               SUB     E                     ;to make it relative (1-# sectors/track)
  EA2E    4F             C               LD      C,A
  EA2F    78             C               LD      A,B
  EA30    9A             C               SBC     A,D
  EA31    47             C               LD      B,A
  EA32    2A F3D0        C               LD      HL,(XLATE)            ;translate this sector according to this table
  EA35    EB             C               EX      DE,HL
  EA36    CD F430        C               CALL    SECTRN                ;let the bios translate it
  EA39    4D             C               LD      C,L
  EA3A    44             C               LD      B,H
  EA3B    C3 F421        C               JP      SETSEC                ;and select it
                         C      
                         C      ;
                         C      ;   Compute block number from record number (SAVNREC) and extent number (SAVEXT)
                         C      ;
  EA3E                   C      GETBLOCK:
  EA3E    21 F3C3        C               LD      HL,BLKSHFT            ;get logical to physical conversion
  EA41    4E             C               LD      C,(HL)                ;note that this is base 2 log of ratio
  EA42    3A F3E3        C               LD      A,(SAVNREC)           ;get record number
  EA45                   C      GETBLK1:
  EA45    B7             C               OR      A                     ;compute (A)=(A)/2^BLKSHFT
  EA46    1F             C               RRA
  EA47    0D             C               DEC     C
  EA48    C2 EA45        C               JP      NZ,GETBLK1
  EA4B    47             C               LD      B,A                   ;save result in (B)
  EA4C    3E 08          C               LD      A,8
  EA4E    96             C               SUB     (HL)
  EA4F    4F             C               LD      C,A                   ;compute (C)=8-BLKSHFT
  EA50    3A F3E2        C               LD      A,(SAVEXT)
  EA53                   C      GETBLK2:
  EA53    0D             C               DEC     C                     ;compute (A)=SAVEXT*2^(8-BLKSHFT)
  EA54    CA EA5C        C               JP      Z,GETBLK3
  EA57    B7             C               OR      A
  EA58    17             C               RLA
  EA59    C3 EA53        C               JP      GETBLK2
  EA5C                   C      GETBLK3:
  EA5C    80             C               ADD     A,B
  EA5D    C9             C               RET
                         C      
                         C      ;
                         C      ;   Routine to extract the (BC) block byte from the fcb pointed to by (PARAMS)
                         C      ;   If this is a big-disk, then these are 16 bit block numbers, else they are 8 bit numbers
                         C      ;   Number is returned in (HL)
                         C      ;
  EA5E                   C      EXTBLK:
  EA5E    2A E943        C               LD      HL,(PARAMS)           ;get fcb address
  EA61    11 0010        C               LD      DE,16                 ;block numbers start 16 bytes into fcb
  EA64    19             C               ADD     HL,DE
  EA65    09             C               ADD     HL,BC
  EA66    3A F3DD        C               LD      A,(BIGDISK)           ;are we using a big-disk?
  EA69    B7             C               OR      A
  EA6A    CA EA71        C               JP      Z,EXTBLK1
  EA6D    6E             C               LD      L,(HL)                ;no, extract an 8 bit number from the fcb
''      MACRO-80 3.44   09-Dec-81       PAGE    1-14


  EA6E    26 00          C               LD      H,0
  EA70    C9             C               RET
  EA71                   C      EXTBLK1:
  EA71    09             C               ADD     HL,BC                 ;yes, extract a 16 bit number
  EA72    5E             C               LD      E,(HL)
  EA73    23             C               INC     HL
  EA74    56             C               LD      D,(HL)
  EA75    EB             C               EX      DE,HL                 ;return in (HL)
  EA76    C9             C               RET
                         C      
                         C      ;
                         C      ;   Compute block number
                         C      ;
  EA77                   C      COMBLK:
  EA77    CD EA3E        C               CALL    GETBLOCK
  EA7A    4F             C               LD      C,A
  EA7B    06 00          C               LD      B,0
  EA7D    CD EA5E        C               CALL    EXTBLK
  EA80    22 F3E5        C               LD      (BLKNMBR),HL
  EA83    C9             C               RET
                         C      
                         C      ;
                         C      ;   Check for a zero block number (unused)
                         C      ;
  EA84                   C      CHKBLK:
  EA84    2A F3E5        C               LD      HL,(BLKNMBR)
  EA87    7D             C               LD      A,L                   ;is it zero?
  EA88    B4             C               OR      H
  EA89    C9             C               RET
                         C      
                         C      ;
                         C      ;   Adjust physical block (BLKNMBR) and convert to logical sector (LOGSECT)
                         C      ;   This is the starting sector of this block
                         C      ;   The actual sector of interest is then added to this and the resulting sector number is stored back in (BLKNMBR)
                         C      ;   This will still have to be adjusted for the track number
                         C      ;
  EA8A                   C      LOGICAL:
  EA8A    3A F3C3        C               LD      A,(BLKSHFT)           ;get log2(physical/logical sectors)
  EA8D    2A F3E5        C               LD      HL,(BLKNMBR)          ;get physical sector desired
  EA90                   C      LOGICL1:
  EA90    29             C               ADD     HL,HL                 ;compute logical sector number
  EA91    3D             C               DEC     A                     ;note logical sectors are 128 bytes long
  EA92    C2 EA90        C               JP      NZ,LOGICL1
  EA95    22 F3E7        C               LD      (LOGSECT),HL          ;save logical sector
  EA98    3A F3C4        C               LD      A,(BLKMASK)           ;get block mask
  EA9B    4F             C               LD      C,A
  EA9C    3A F3E3        C               LD      A,(SAVNREC)           ;get next sector to access
  EA9F    A1             C               AND     C                     ;extract the relative position within physical block
  EAA0    B5             C               OR      L                     ;and add it too logical sector
  EAA1    6F             C               LD      L,A
  EAA2    22 F3E5        C               LD      (BLKNMBR),HL          ;and store
  EAA5    C9             C               RET
                         C      
                         C      ;
                         C      ;   Set (HL) to point to extent byte in fcb
                         C      ;
  EAA6                   C      SETEXT:
  EAA6    2A E943        C               LD      HL,(PARAMS)
  EAA9    11 000C        C               LD      DE,12                 ;it is the twelth byte
  EAAC    19             C               ADD     HL,DE
  EAAD    C9             C               RET
                         C      
                         C      ;
                         C      ;   Set (HL) to point to record count byte in fcb and (DE) to next record number byte
                         C      ;
  EAAE                   C      SETHLDE:
  EAAE    2A E943        C               LD      HL,(PARAMS)
  EAB1    11 000F        C               LD      DE,15                 ;record count byte (#15)
  EAB4    19             C               ADD     HL,DE
  EAB5    EB             C               EX      DE,HL
  EAB6    21 0011        C               LD      HL,17                 ;next record number (#32)
  EAB9    19             C               ADD     HL,DE
  EABA    C9             C               RET
                         C      
                         C      ;
                         C      ;   Save current file data from fcb
                         C      ;
  EABB                   C      STRDATA:
  EABB    CD EAAE        C               CALL    SETHLDE
  EABE    7E             C               LD      A,(HL)                ;get and store record count byte
  EABF    32 F3E3        C               LD      (SAVNREC),A
  EAC2    EB             C               EX      DE,HL
  EAC3    7E             C               LD      A,(HL)                ;get and store next record number byte
''      MACRO-80 3.44   09-Dec-81       PAGE    1-15


  EAC4    32 F3E1        C               LD      (SAVNXT),A
  EAC7    CD EAA6        C               CALL    SETEXT                ;point to extent byte
  EACA    3A F3C5        C               LD      A,(EXTMASK)           ;get extent mask
  EACD    A6             C               AND     (HL)
  EACE    32 F3E2        C               LD      (SAVEXT),A            ;and save extent here
  EAD1    C9             C               RET
                         C      
                         C      ;
                         C      ;   Set the next record to access
                         C      ;   If (MODE) is set to 2, then the last record byte (SAVNREC) has the correct number to access
                         C      ;   For sequential access, (MODE) will be equal to 1
                         C      ;
  EAD2                   C      SETNREC:
  EAD2    CD EAAE        C               CALL    SETHLDE
  EAD5    3A F3D5        C               LD      A,(MODE)              ;get sequential flag (=1)
  EAD8    FE 02          C               CP      2                     ;a 2 indicates that no adder is needed
  EADA    C2 EADE        C               JP      NZ,STNREC1
  EADD    AF             C               XOR     A                     ;clear adder (random access?)
  EADE                   C      STNREC1:
  EADE    4F             C               LD      C,A
  EADF    3A F3E3        C               LD      A,(SAVNREC)           ;get last record number
  EAE2    81             C               ADD     A,C                   ;increment record count
  EAE3    77             C               LD      (HL),A                ;and set fcb's next record byte
  EAE4    EB             C               EX      DE,HL
  EAE5    3A F3E1        C               LD      A,(SAVNXT)            ;get next record byte from storage
  EAE8    77             C               LD      (HL),A                ;and put this into fcb as number of records used
  EAE9    C9             C               RET
                         C      
                         C      ;
                         C      ;   Shift (HL) right (C) bits
                         C      ;
  EAEA                   C      SHIFTR:
  EAEA    0C             C               INC     C
  EAEB                   C      SHIFTR1:
  EAEB    0D             C               DEC     C
  EAEC    C8             C               RET     Z
  EAED    7C             C               LD      A,H
  EAEE    B7             C               OR      A
  EAEF    1F             C               RRA
  EAF0    67             C               LD      H,A
  EAF1    7D             C               LD      A,L
  EAF2    1F             C               RRA
  EAF3    6F             C               LD      L,A
  EAF4    C3 EAEB        C               JP      SHIFTR1
                         C      
                         C      ;
                         C      ;   Compute the check-sum for the directory buffer
                         C      ;   Return integer sum in (A)
                         C      ;
  EAF7                   C      CHECKSUM:
  EAF7    0E 80          C               LD      C,128                 ;length of buffer
  EAF9    2A F3B9        C               LD      HL,(DIRBUF)           ;get its location
  EAFC    AF             C               XOR     A                     ;clear summation byte
  EAFD                   C      CHKSUM1:
  EAFD    86             C               ADD     A,(HL)                ;and compute sum ignoring carries
  EAFE    23             C               INC     HL
  EAFF    0D             C               DEC     C
  EB00    C2 EAFD        C               JP      NZ,CHKSUM1
  EB03    C9             C               RET
                         C      
                         C      ;
                         C      ;   Shift (HL) left (C) bits
                         C      ;
  EB04                   C      SHIFTL:
  EB04    0C             C               INC    C
  EB05                   C      SHIFTL1:
  EB05    0D             C               DEC    C
  EB06    C8             C               RET    Z
  EB07    29             C               ADD    HL,HL                  ;shift left 1 bit
  EB08    C3 EB05        C               JP     SHIFTL1
                         C      
                         C      ;
                         C      ;   Routine to set a bit in a 16 bit value contained in (BC)
                         C      ;   The bit set depends on the current drive selection
                         C      ;
  EB0B                   C      SETBIT:
  EB0B    C5             C               PUSH    BC                    ;save 16 bit word
  EB0C    3A E942        C               LD      A,(ACTIVE)            ;get active drive
  EB0F    4F             C               LD      C,A
  EB10    21 0001        C               LD      HL,1
  EB13    CD EB04        C               CALL    SHIFTL                ;shift bit 0 into place
  EB16    C1             C               POP     BC                    ;now 'or' this with the original word
  EB17    79             C               LD      A,C
''      MACRO-80 3.44   09-Dec-81       PAGE    1-16


  EB18    B5             C               OR      L
  EB19    6F             C               LD      L,A                   ;low byte done, do high byte
  EB1A    78             C               LD      A,B
  EB1B    B4             C               OR      H
  EB1C    67             C               LD      H,A
  EB1D    C9             C               RET
                         C      
                         C      ;
                         C      ;   Extract the write protect status bit for the current drive
                         C      ;   The result is returned in (A), bit 0
                         C      ;
  EB1E                   C      GETWPRT:
  EB1E    2A F3AD        C               LD      HL,(WRTPRT)           ;get status bytes
  EB21    3A E942        C               LD      A,(ACTIVE)            ;which drive is current?
  EB24    4F             C               LD      C,A
  EB25    CD EAEA        C               CALL    SHIFTR                ;shift status such that bit 0 is the
  EB28    7D             C               LD      A,L                   ;one of interest for this drive
  EB29    E6 01          C               AND     001H                  ;and isolate it
  EB2B    C9             C               RET
                         C      
                         C      ;
                         C      ;   Function to write protect the current disk
                         C      ;
  EB2C                   C      WRTPRTD:
  EB2C    21 F3AD        C               LD      HL,WRTPRT             ;point to status word
  EB2F    4E             C               LD      C,(HL)                ;set (BC) equal to the status
  EB30    23             C               INC     HL
  EB31    46             C               LD      B,(HL)
  EB32    CD EB0B        C               CALL    SETBIT                ;and set this bit according to current drive
  EB35    22 F3AD        C               LD      (WRTPRT),HL           ;then save
  EB38    2A F3C8        C               LD      HL,(DIRSIZE)          ;now save directory size limit
  EB3B    23             C               INC     HL                    ;remember the last one
  EB3C    EB             C               EX      DE,HL
  EB3D    2A F3B3        C               LD      HL,(SCRATCH1)         ;and store it here
  EB40    73             C               LD      (HL),E                ;put low byte
  EB41    23             C               INC     HL
  EB42    72             C               LD      (HL),D                ;then high byte
  EB43    C9             C               RET
                         C      
                         C      ;
                         C      ;   Check for a read only file
                         C      ;
  EB44                   C      CHKROFL:
  EB44    CD EB5E        C               CALL    FCB2HL                ;set (HL) to file entry in directory buffer
  EB47                   C      CKROF1:
  EB47    11 0009        C               LD      DE,9                  ;look at bit 7 of the ninth byte
  EB4A    19             C               ADD     HL,DE
  EB4B    7E             C               LD      A,(HL)
  EB4C    17             C               RLA
  EB4D    D0             C               RET     NC                    ;return if ok
  EB4E    21 E60F        C               LD      HL,ROFILE             ;else, print error message and terminate
  EB51    C3 E94A        C               JP      JUMPHL
                         C      
                         C      ;
                         C      ;   Check the write protect status of the active disk
                         C      ;
  EB54                   C      CHKWPRT:
  EB54    CD EB1E        C               CALL    GETWPRT
  EB57    C8             C               RET     Z                     ;return if ok
  EB58    21 E60D        C               LD      HL,RODISK             ;else print message and terminate
  EB5B    C3 E94A        C               JP      JUMPHL
                         C      
                         C      ;
                         C      ;   Routine to set (HL) pointing to the proper entry in the directory buffer
                         C      ;
  EB5E                   C      FCB2HL:
  EB5E    2A F3B9        C               LD      HL,(DIRBUF)           ;get address of buffer
  EB61    3A F3E9        C               LD      A,(FCBPOS)            ;relative position of file
                         C      ;
                         C      ;   Routine to add (A) to (HL).
                         C      ;
  EB64                   C      ADDA2HL:
  EB64    85             C               ADD     A,L
  EB65    6F             C               LD      L,A
  EB66    D0             C               RET     NC
  EB67    24             C               INC     H                     ;take care of any carry
  EB68    C9             C               RET
                         C      
                         C      ;
                         C      ;   Routine to get the 's2' byte from the fcb supplied in the initial parameter specification
                         C      ;
  EB69                   C      GETS2:
  EB69    2A E943        C               LD      HL,(PARAMS)           ;get address of fcb
''      MACRO-80 3.44   09-Dec-81       PAGE    1-17


  EB6C    11 000E        C               LD      DE,14                 ;relative position of 's2'
  EB6F    19             C               ADD     HL,DE
  EB70    7E             C               LD      A,(HL)                ;extract this byte
  EB71    C9             C               RET
                         C      
                         C      ;
                         C      ;   Clear the 's2' byte in the fcb
                         C      ;
  EB72                   C      CLEARS2:
  EB72    CD EB69        C               CALL    GETS2                 ;this sets (HL) pointing to it
  EB75    36 00          C               LD      (HL),0                ;now clear it
  EB77    C9             C               RET
                         C      
                         C      ;
                         C      ;   Set bit 7 in the 's2' byte of the fcb
                         C      ;
  EB78                   C      SETS2B7:
  EB78    CD EB69        C               CALL    GETS2                 ;get the byte
  EB7B    F6 80          C               OR      080H                  ;and set bit 7
  EB7D    77             C               LD      (HL),A                ;then store
  EB7E    C9             C               RET
                         C      
                         C      ;
                         C      ;   Compare (FILEPOS) with (SCRATCH1) and set flags based on the difference
                         C      ;   This checks to see if there are more file names in the directory
                         C      ;   We are at (FILEPOS) and there are (SCRATCH1) of them to check
                         C      ;
  EB7F                   C      MOREFLS:
  EB7F    2A F3EA        C               LD      HL,(FILEPOS)          ;we are here
  EB82    EB             C               EX      DE,HL
  EB83    2A F3B3        C               LD      HL,(SCRATCH1)         ;and don't go past here
  EB86    7B             C               LD      A,E                   ;compute difference but don't keep
  EB87    96             C               SUB     (HL)
  EB88    23             C               INC     HL
  EB89    7A             C               LD      A,D
  EB8A    9E             C               SBC     A,(HL)                ;set carry if no more names
  EB8B    C9             C               RET
                         C      
                         C      ;
                         C      ;   Call this routine to prevent (SCRATCH1) from being greater than (FILEPOS)
                         C      ;
  EB8C                   C      CHKNMBR:
  EB8C    CD EB7F        C               CALL    MOREFLS               ;SCRATCH1 too big?
  EB8F    D8             C               RET     C
  EB90    13             C               INC     DE                    ;yes, reset it to (FILEPOS)
  EB91    72             C               LD      (HL),D
  EB92    2B             C               DEC     HL
  EB93    73             C               LD      (HL),E
  EB94    C9             C               RET
                         C      
                         C      ;
                         C      ;   Compute (HL)=(DE)-(HL)
                         C      ;
  EB95                   C      SUBHL:
  EB95    7B             C               LD      A,E                   ;compute difference
  EB96    95             C               SUB     L
  EB97    6F             C               LD      L,A                   ;store low byte
  EB98    7A             C               LD      A,D
  EB99    9C             C               SBC     A,H
  EB9A    67             C               LD      H,A                   ;and then high byte
  EB9B    C9             C               RET
                         C      
                         C      ;
                         C      ;   Set the directory checksum byte
                         C      ;
  EB9C                   C      SETDIR:
  EB9C    0E FF          C               LD      C,0FFH
                         C      ;
                         C      ;   Routine to set or compare the directory checksum byte
                         C      ;   If (C)=0ffh, then this will set the checksum byte
                         C      ;   Else the byte will be checked
                         C      ;   If the check fails (the disk has been changed), then this disk will be write protected
                         C      ;
  EB9E                   C      CHECKDIR:
  EB9E    2A F3EC        C               LD      HL,(CKSUMTBL)
  EBA1    EB             C               EX      DE,HL
  EBA2    2A F3CC        C               LD      HL,(ALLOC1)
  EBA5    CD EB95        C               CALL    SUBHL
  EBA8    D0             C               RET     NC                    ;ok if (CKSUMTBL) > (ALLOC1), so return
  EBA9    C5             C               PUSH    BC
  EBAA    CD EAF7        C               CALL    CHECKSUM              ;else compute checksum
  EBAD    2A F3BD        C               LD      HL,(CHKVECT)          ;get address of checksum table
  EBB0    EB             C               EX      DE,HL
''      MACRO-80 3.44   09-Dec-81       PAGE    1-18


  EBB1    2A F3EC        C               LD      HL,(CKSUMTBL)
  EBB4    19             C               ADD     HL,DE                 ;set (HL) to point to byte for this drive
  EBB5    C1             C               POP     BC
  EBB6    0C             C               INC     C                     ;set or check ?
  EBB7    CA EBC4        C               JP      Z,CHKDIR1
  EBBA    BE             C               CP      (HL)                  ;check them
  EBBB    C8             C               RET     Z                     ;return if they are the same
  EBBC    CD EB7F        C               CALL    MOREFLS               ;not the same, do we care?
  EBBF    D0             C               RET     NC
  EBC0    CD EB2C        C               CALL    WRTPRTD               ;yes, mark this as write protected
  EBC3    C9             C               RET
  EBC4                   C      CHKDIR1:
  EBC4    77             C               LD      (HL),A                ;just set the byte
  EBC5    C9             C               RET
                         C      
                         C      ;
                         C      ;   Do a write to the directory of the current disk
                         C      ;
  EBC6                   C      DIRWRITE:
  EBC6    CD EB9C        C               CALL    SETDIR                ;set checksum byte
  EBC9    CD EBE0        C               CALL    DIRDMA                ;set directory dma address
  EBCC    0E 01          C               LD      C,1                   ;tell the bios to actually write
  EBCE    CD E9B8        C               CALL    DOWRITE               ;then do the write
  EBD1    C3 EBDA        C               JP      DEFDMA
                         C      
                         C      ;
                         C      ;   Read from the directory
                         C      ;
  EBD4                   C      DIRREAD:
  EBD4    CD EBE0        C               CALL    DIRDMA                ;set the directory dma address
  EBD7    CD E9B2        C               CALL    DOREAD                ;and read it
                         C      ;
                         C      ;   Routine to set the dma address to the users choice
                         C      ;
  EBDA                   C      DEFDMA:
  EBDA    21 F3B1        C               LD      HL,USERDMA            ;reset the default dma address and return
  EBDD    C3 EBE3        C               JP      DIRDMA1
                         C      
                         C      ;
                         C      ;   Routine to set the dma address for directory work
                         C      ;
  EBE0                   C      DIRDMA:
  EBE0    21 F3B9        C               LD      HL,DIRBUF
                         C      ;
                         C      ;   Set the dma address
                         C      ;   On entry, (HL) points to word containing the desired dma address
                         C      ;
  EBE3                   C      DIRDMA1:
  EBE3    4E             C               LD      C,(HL)
  EBE4    23             C               INC     HL
  EBE5    46             C               LD      B,(HL)                ;setup (BC) and go to the bios to set it
  EBE6    C3 F424        C               JP      SETDMA
                         C      
                         C      ;
                         C      ;   Move the directory buffer into user's dma space
                         C      ;
  EBE9                   C      MOVEDIR:
  EBE9    2A F3B9        C               LD      HL,(DIRBUF)           ;buffer is located here, and
  EBEC    EB             C               EX      DE,HL
  EBED    2A F3B1        C               LD      HL,(USERDMA)          ;put it here
  EBF0    0E 80          C               LD      C,128                 ;this is its length
  EBF2    C3 E94F        C               JP      DE2HL                 ;move it now and return
                         C      
                         C      ;
                         C      ;   Check (FILEPOS) and set the zero flag if it equals 0ffffh
                         C      ;
  EBF5                   C      CKFILPOS:
  EBF5    21 F3EA        C               LD      HL,FILEPOS
  EBF8    7E             C               LD      A,(HL)
  EBF9    23             C               INC     HL
  EBFA    BE             C               CP      (HL)                  ;are both bytes the same?
  EBFB    C0             C               RET     NZ
  EBFC    3C             C               INC     A                     ;yes, but are they each 0ffh?
  EBFD    C9             C               RET
                         C      
                         C      ;
                         C      ;   Set location (FILEPOS) to 0ffffh
                         C      ;
  EBFE                   C      STFILPOS:
  EBFE    21 FFFF        C               LD      HL,0FFFFH
  EC01    22 F3EA        C               LD      (FILEPOS),HL
  EC04    C9             C               RET
                         C      
''      MACRO-80 3.44   09-Dec-81       PAGE    1-19


                         C      ;
                         C      ;   Move on to the next file position within the current directory buffer
                         C      ;   If no more exist, set pointer to 0ffffh and the calling routine will check for this
                         C      ;   Enter with (C) equal to 0ffh to cause the checksum byte to be set, else we
                         C      ;     will check this disk and set write protect if checksums are
                         C      ;     not the same (applies only if another directory sector must be read)
                         C      ;
  EC05                   C      NXENTRY:
  EC05    2A F3C8        C               LD      HL,(DIRSIZE)          ;get directory entry size limit
  EC08    EB             C               EX      DE,HL
  EC09    2A F3EA        C               LD      HL,(FILEPOS)          ;get current count
  EC0C    23             C               INC     HL                    ;go on to the next one
  EC0D    22 F3EA        C               LD      (FILEPOS),HL
  EC10    CD EB95        C               CALL    SUBHL                 ;(HL)=(DIRSIZE)-(FILEPOS)
  EC13    D2 EC19        C               JP      NC,NXENT1             ;is there more room left?
  EC16    C3 EBFE        C               JP      STFILPOS              ;no. Set this flag and return
  EC19                   C      NXENT1:
  EC19    3A F3EA        C               LD      A,(FILEPOS)           ;get file position within directory
  EC1C    E6 03          C               AND     003H                  ;only look within this sector (only 4 entries fit)
  EC1E    06 05          C               LD      B,5                   ;convert to relative position (32 bytes each)
  EC20                   C      NXENT2:
  EC20    87             C               ADD     A,A                   ;note that this is not efficient code
  EC21    05             C               DEC     B                     ;5 'ADD A's would be better
  EC22    C2 EC20        C               JP      NZ,NXENT2
  EC25    32 F3E9        C               LD      (FCBPOS),A            ;save it as position of fcb
  EC28    B7             C               OR      A
  EC29    C0             C               RET     NZ                    ;return if we are within buffer
  EC2A    C5             C               PUSH    BC
  EC2B    CD E9C3        C               CALL    TRKSEC                ;we need the next directory sector
  EC2E    CD EBD4        C               CALL    DIRREAD
  EC31    C1             C               POP     BC
  EC32    C3 EB9E        C               JP      CHECKDIR
                         C      
                         C      ;
                         C      ;   Routine to to get a bit from the disk space allocation map
                         C      ;   It is returned in (A), bit position 0. On entry to here, set (BC) to the block number on the disk to check
                         C      ;   On return, (D) will contain the original bit position for this block number and (HL) will point to the address for it
                         C      ;
  EC35                   C      CKBITMAP:
  EC35    79             C               LD      A,C                   ;determine bit number of interest
  EC36    E6 07          C               AND     007H                  ;compute (D)=(E)=(C and 7)+1
  EC38    3C             C               INC     A
  EC39    5F             C               LD      E,A                   ;save particular bit number
  EC3A    57             C               LD      D,A
                         C      ;
                         C      ;   compute (BC)=(BC)/8
                         C      ;
  EC3B    79             C               LD      A,C
  EC3C    0F             C               RRCA                          ;now shift right 3 bits
  EC3D    0F             C               RRCA
  EC3E    0F             C               RRCA
  EC3F    E6 1F          C               AND     01FH                  ;and clear bits 7,6,5
  EC41    4F             C               LD      C,A
  EC42    78             C               LD      A,B
  EC43    87             C               ADD     A,A                   ;now shift (B) into bits 7,6,5
  EC44    87             C               ADD     A,A
  EC45    87             C               ADD     A,A
  EC46    87             C               ADD     A,A
  EC47    87             C               ADD     A,A
  EC48    B1             C               OR      C                     ;and add in (C)
  EC49    4F             C               LD      C,A                   ;ok, (C) ha been completed
  EC4A    78             C               LD      A,B                   ;is there a better way of doing this?
  EC4B    0F             C               RRCA
  EC4C    0F             C               RRCA
  EC4D    0F             C               RRCA
  EC4E    E6 1F          C               AND    01FH
  EC50    47             C               LD      B,A                   ;and now (B) is completed
                         C      ;
                         C      ;   use this as an offset into the disk space allocation table
                         C      ;
  EC51    2A F3BF        C               LD      HL,(ALOCVECT)
  EC54    09             C               ADD     HL,BC
  EC55    7E             C               LD      A,(HL)                ;now get correct byte
  EC56                   C      CKBMAP1:
  EC56    07             C               RLCA                          ;get correct bit into position 0
  EC57    1D             C               DEC     E
  EC58    C2 EC56        C               JP      NZ,CKBMAP1
  EC5B    C9             C               RET
                         C      
                         C      ;
                         C      ;   Set or clear the bit map such that block number (BC) will be marked as used
                         C      ;   On entry, if (E)=0 then this bit will be cleared, if it equals 1 then it will be set (don't use anyother values)
                         C      ;
''      MACRO-80 3.44   09-Dec-81       PAGE    1-20


  EC5C                   C      STBITMAP:
  EC5C    D5             C               PUSH    DE
  EC5D    CD EC35        C               CALL    CKBITMAP              ;get the byte of interest
  EC60    E6 FE          C               AND     0FEH                  ;clear the affected bit
  EC62    C1             C               POP     BC
  EC63    B1             C               OR      C                     ;and now set it acording to (C)
                         C      ;
                         C      ;   entry to restore the original bit position and then store in table
                         C      ;   (A)  contains the value,
                         C      ;   (D)  contains the bit position (1-8), and
                         C      ;   (HL) points to the address within the space allocation table for this byte
                         C      ;
  EC64                   C      STBMAP1:
  EC64    0F             C               RRCA                          ;restore original bit position
  EC65    15             C               DEC     D
  EC66    C2 EC64        C               JP      NZ,STBMAP1
  EC69    77             C               LD      (HL),A                ;and stor byte in table
  EC6A    C9             C               RET
                         C      
                         C      ;
                         C      ;   Set/clear space used bits in allocation map for this file
                         C      ;   On entry, (C)=1 to set the map and (C)=0 to clear it
                         C      ;
  EC6B                   C      SETFILE:
  EC6B    CD EB5E        C               CALL    FCB2HL                ;get address of fcb
  EC6E    11 0010        C               LD      DE,16
  EC71    19             C               ADD     HL,DE                 ;get to block number bytes
  EC72    C5             C               PUSH    BC
  EC73    0E 11          C               LD      C,17                  ;check all 17 bytes (max) of table
  EC75                   C      SETFL1:
  EC75    D1             C               POP     DE
  EC76    0D             C               DEC     C                     ;done all bytes yet?
  EC77    C8             C               RET     Z
  EC78    D5             C               PUSH    DE
  EC79    3A F3DD        C               LD      A,(BIGDISK)           ;check disk size for 16 bit block numbers
  EC7C    B7             C               OR      A
  EC7D    CA EC88        C               JP      Z,SETFL2
  EC80    C5             C               PUSH    BC                    ;only 8 bit numbers. set (BC) to this one
  EC81    E5             C               PUSH    HL
  EC82    4E             C               LD      C,(HL)                ;get low byte from table, always
  EC83    06 00          C               LD      B,0                   ;set high byte to zero
  EC85    C3 EC8E        C               JP      SETFL3
  EC88                   C      SETFL2:
  EC88    0D             C               DEC     C                     ;for 16 bit block numbers, adjust counter
  EC89    C5             C               PUSH    BC
  EC8A    4E             C               LD      C,(HL)                ;now get both the low and high bytes
  EC8B    23             C               INC     HL
  EC8C    46             C               LD      B,(HL)
  EC8D    E5             C               PUSH    HL
  EC8E                   C      SETFL3:
  EC8E    79             C               LD      A,C                   ;block used?
  EC8F    B0             C               OR      B
  EC90    CA EC9D        C               JP      Z,SETFL4
  EC93    2A F3C6        C               LD      HL,(DSKSIZE)          ;is this block number within the
  EC96    7D             C               LD      A,L                   ;space on the disk?
  EC97    91             C               SUB     C
  EC98    7C             C               LD      A,H
  EC99    98             C               SBC     A,B
  EC9A    D4 EC5C        C               CALL    NC,STBITMAP           ;yes, set the proper bit
  EC9D                   C      SETFL4:
  EC9D    E1             C               POP     HL                    ;point to next block number in fcb
  EC9E    23             C               INC     HL
  EC9F    C1             C               POP     BC
  ECA0    C3 EC75        C               JP      SETFL1
                         C      
                         C               PAGE
''      MACRO-80 3.44   09-Dec-81       PAGE    1-21


                         C      
                         C      ;
                         C      ;   Construct the space used allocation bit map for the active
                         C      ; drive. If a file name starts with '$' and it is under the
                         C      ; current user number, then (STATUS) is set to minus 1. Otherwise
                         C      ; it is not set at all.
                         C      ;
  ECA3                   C      BITMAP:
  ECA3    2A F3C6        C               LD      HL,(DSKSIZE)          ;compute size of allocation table
  ECA6    0E 03          C               LD      C,3
  ECA8    CD EAEA        C               CALL    SHIFTR                ;(HL)=(HL)/8
  ECAB    23             C               INC     HL                    ;at lease 1 byte
  ECAC    44             C               LD      B,H
  ECAD    4D             C               LD      C,L                   ;set (BC) to the allocation table length
                         C      ;
                         C      ;   Initialize the bitmap for this drive. Right now, the first two bytes are specified by the disk parameter block
                         C      ;   However a patch could be entered here if it were necessary to setup this table in a special mannor
                         C      ;   For example, the bios could determine locations of 'bad blocks' and set them as already 'used' in the map
                         C      ;
  ECAE    2A F3BF        C               LD      HL,(ALOCVECT)         ;now zero out the table now
  ECB1                   C      BITMAP1:
  ECB1    36 00          C               LD      (HL),000H
  ECB3    23             C               INC     HL
  ECB4    0B             C               DEC     BC
  ECB5    78             C               LD      A,B
  ECB6    B1             C               OR      C
  ECB7    C2 ECB1        C               JP      NZ,BITMAP1
  ECBA    2A F3CA        C               LD      HL,(ALLOC0)           ;get initial space used by directory
  ECBD    EB             C               EX      DE,HL
  ECBE    2A F3BF        C               LD      HL,(ALOCVECT)         ;and put this into map
  ECC1    73             C               LD      (HL),E
  ECC2    23             C               INC     HL
  ECC3    72             C               LD      (HL),D
                         C      ;
                         C      ;   End of initialization portion
                         C      ;
  ECC4    CD E9A1        C               CALL    HOMEDRV               ;now home the drive
  ECC7    2A F3B3        C               LD      HL,(SCRATCH1)
  ECCA    36 03          C               LD      (HL),3                ;force next directory request to read in a sector
  ECCC    23             C               INC     HL
  ECCD    36 00          C               LD      (HL),0
  ECCF    CD EBFE        C               CALL    STFILPOS              ;clear initial file position also
  ECD2                   C      BITMAP2:
  ECD2    0E FF          C               LD      C,0FFH                ;read next file name in directory
  ECD4    CD EC05        C               CALL    NXENTRY               ;and set checksum byte
  ECD7    CD EBF5        C               CALL    CKFILPOS              ;is there another file?
  ECDA    C8             C               RET     Z
  ECDB    CD EB5E        C               CALL    FCB2HL                ;yes, get its address
  ECDE    3E E5          C               LD      A,0E5H
  ECE0    BE             C               CP      (HL)                  ;empty file entry?
  ECE1    CA ECD2        C               JP      Z,BITMAP2
  ECE4    3A E941        C               LD      A,(USERNO)          ;no, correct user number?
  ECE7    BE             C               CP      (HL)
  ECE8    C2 ECF6        C               JP      NZ,BITMAP3
  ECEB    23             C               INC     HL
  ECEC    7E             C               LD      A,(HL)                ;yes, does name start with a '$'?
  ECED    D6 24          C               SUB     '$'
  ECEF    C2 ECF6        C               JP      NZ,BITMAP3
  ECF2    3D             C               DEC     A                     ;yes, set status to minus one
  ECF3    32 E945        C               LD      (STATUS),A
  ECF6                   C      BITMAP3:
  ECF6    0E 01          C               LD      C,1                   ;now set this file's space as used in bit map
  ECF8    CD EC6B        C               CALL    SETFILE
  ECFB    CD EB8C        C               CALL    CHKNMBR               ;keep (SCRATCH1) in bounds
  ECFE    C3 ECD2        C               JP      BITMAP2
                         C      
                         C      ;
                         C      ;   Set the status (STATUS) and return
                         C      ;
  ED01                   C      STSTATUS:
  ED01    3A F3D4        C               LD      A,(FNDSTAT)
  ED04    C3 E901        C               JP      SETSTAT
                         C      
                         C      ;
                         C      ;   Check extents in (A) and (C). Set the zero flag if they are the same
                         C      ;   The number of 16k chunks of disk space that the directory extent covers is expressad is (EXTMASK+1)
                         C      ;   No registers are modified.
                         C      ;
  ED07                   C      SAMEXT:
  ED07    C5             C               PUSH    BC
  ED08    F5             C               PUSH    AF
  ED09    3A F3C5        C               LD      A,(EXTMASK)           ;get extent mask and use it to
''      MACRO-80 3.44   09-Dec-81       PAGE    1-22


  ED0C    2F             C               CPL                           ;to compare both extent numbers
  ED0D    47             C               LD      B,A                   ;save resulting mask here
  ED0E    79             C               LD      A,C                   ;mask first extent and save in (C)
  ED0F    A0             C               AND     B
  ED10    4F             C               LD      C,A
  ED11    F1             C               POP     AF                    ;now mask second extent and compare
  ED12    A0             C               AND     B                     ;with the first one
  ED13    91             C               SUB     C
  ED14    E6 1F          C               AND     01FH                  ;(* only check buts 0-4 *)
  ED16    C1             C               POP     BC                    ;the zero flag is set if they are the same
  ED17    C9             C               RET                           ;restore (BC) and return
                         C      
                         C               PAGE
''      MACRO-80 3.44   09-Dec-81       PAGE    1-23


                         C      
                         C      ;
                         C      ;   Search for the first occurence of a file name. On entry,
                         C      ;     register (C) should contain the number of bytes of the fcb that must match
                         C      ;
  ED18                   C      FINDFST:
  ED18    3E FF          C               LD      A,0FFH
  ED1A    32 F3D4        C               LD      (FNDSTAT),A
  ED1D    21 F3D8        C               LD      HL,COUNTER            ;save character count
  ED20    71             C               LD      (HL),C
  ED21    2A E943        C               LD      HL,(PARAMS)           ;get filename to match
  ED24    22 F3D9        C               LD      (SAVEFCB),HL          ;and save
  ED27    CD EBFE        C               CALL    STFILPOS              ;clear initial file position (set to 0ffffh)
  ED2A    CD E9A1        C               CALL    HOMEDRV               ;home the drive
                         C      ;
                         C      ;   Entry to locate the next occurence of a filename within the directory
                         C      ;   The disk is not expected to have been changed
                         C      ;   If it was, then it will be write protected
                         C      ;
  ED2D                   C      FINDNXT:
  ED2D    0E 00          C               LD      C,0                   ;write protect the disk if changed
  ED2F    CD EC05        C               CALL    NXENTRY               ;get next filename entry in directory
  ED32    CD EBF5        C               CALL    CKFILPOS              ;is file position = 0ffffh?
  ED35    CA ED94        C               JP      Z,FNDNXT6             ;yes, exit now then
  ED38    2A F3D9        C               LD      HL,(SAVEFCB)          ;set (DE) pointing to filename to match
  ED3B    EB             C               EX      DE,HL
  ED3C    1A             C               LD      A,(DE)
  ED3D    FE E5          C               CP      0E5H                  ;empty directory entry?
  ED3F    CA ED4A        C               JP      Z,FNDNXT1             ;(* are we trying to reserect erased entries? *)
  ED42    D5             C               PUSH    DE
  ED43    CD EB7F        C               CALL    MOREFLS               ;more files in directory?
  ED46    D1             C               POP     DE
  ED47    D2 ED94        C               JP      NC,FNDNXT6            ;no more. Exit now
  ED4A                   C      FNDNXT1:
  ED4A    CD EB5E        C               CALL    FCB2HL                ;get address of this fcb in directory
  ED4D    3A F3D8        C               LD      A,(COUNTER)           ;get number of bytes (characters) to check
  ED50    4F             C               LD      C,A
  ED51    06 00          C               LD      B,0                   ;initialize byte position counter
  ED53                   C      FNDNXT2:
  ED53    79             C               LD      A,C                   ;are we done with the compare?
  ED54    B7             C               OR      A
  ED55    CA ED83        C               JP      Z,FNDNXT5
  ED58    1A             C               LD      A,(DE)                ;no, check next byte
  ED59    FE 3F          C               CP      '?'                   ;don't care about this character?
  ED5B    CA ED7C        C               JP      Z,FNDNXT4
  ED5E    78             C               LD      A,B                   ;get bytes position in fcb
  ED5F    FE 0D          C               CP      13                    ;don't care about the thirteenth byte either
  ED61    CA ED7C        C               JP      Z,FNDNXT4
  ED64    FE 0C          C               CP      12                    ;extent byte?
  ED66    1A             C               LD      A,(DE)
  ED67    CA ED73        C               JP      Z,FNDNXT3
  ED6A    96             C               SUB     (HL)                  ;otherwise compare characters
  ED6B    E6 7F          C               AND     07FH
  ED6D    C2 ED2D        C               JP      NZ,FINDNXT            ;not the same, check next entry
  ED70    C3 ED7C        C               JP      FNDNXT4               ;so far so good, keep checking
  ED73                   C      FNDNXT3:
  ED73    C5             C               PUSH    BC                    ;check the extent byte here
  ED74    4E             C               LD      C,(HL)
  ED75    CD ED07        C               CALL    SAMEXT
  ED78    C1             C               POP     BC
  ED79    C2 ED2D        C               JP      NZ,FINDNXT            ;not the same, look some more
                         C      ;
                         C      ;   So far the names compare
                         C      ;   Bump pointers to the next byte and continue until all (C) characters have been checked
                         C      ;
  ED7C                   C      FNDNXT4:
  ED7C    13             C               INC     DE                    ;bump pointers
  ED7D    23             C               INC     HL
  ED7E    04             C               INC     B
  ED7F    0D             C               DEC     C                     ;adjust character counter
  ED80    C3 ED53        C               JP      FNDNXT2
  ED83                   C      FNDNXT5:
  ED83    3A F3EA        C               LD      A,(FILEPOS)           ;return the position of this entry
  ED86    E6 03          C               AND     003H
  ED88    32 E945        C               LD      (STATUS),A
  ED8B    21 F3D4        C               LD      HL,FNDSTAT
  ED8E    7E             C               LD      A,(HL)
  ED8F    17             C               RLA
  ED90    D0             C               RET     NC
  ED91    AF             C               XOR     A
  ED92    77             C               LD      (HL),A
  ED93    C9             C               RET
''      MACRO-80 3.44   09-Dec-81       PAGE    1-24


                         C      ;
                         C      ;   Filename was not found. Set appropriate status
                         C      ;
  ED94                   C      FNDNXT6:
  ED94    CD EBFE        C               CALL    STFILPOS              ;set (FILEPOS) to 0ffffh
  ED97    3E FF          C               LD      A,0FFH                ;say not located
  ED99    C3 E901        C               JP      SETSTAT
                         C      
                         C               PAGE
''      MACRO-80 3.44   09-Dec-81       PAGE    1-25


                         C      
                         C      ;
                         C      ;   Erase files from the directory
                         C      ;   Only the first byte of the fcb will be affected. It is set to (E5)
                         C      ;
  ED9C                   C      ERAFILE:
  ED9C    CD EB54        C               CALL    CHKWPRT               ;is disk write protected?
  ED9F    0E 0C          C               LD      C,12                  ;only compare file names
  EDA1    CD ED18        C               CALL    FINDFST               ;get first file name
  EDA4                   C      ERAFIL1:
  EDA4    CD EBF5        C               CALL    CKFILPOS              ;any found?
  EDA7    C8             C               RET     Z                     ;nope, we must be done
  EDA8    CD EB44        C               CALL    CHKROFL               ;is file read only?
  EDAB    CD EB5E        C               CALL    FCB2HL                ;nope, get address of fcb and
  EDAE    36 E5          C               LD      (HL),0E5H             ;set first byte to 'empty'
  EDB0    0E 00          C               LD      C,0                   ;clear the space from the bit map
  EDB2    CD EC6B        C               CALL    SETFILE
  EDB5    CD EBC6        C               CALL    DIRWRITE              ;now write the directory sector back out
  EDB8    CD ED2D        C               CALL    FINDNXT               ;find the next file name
  EDBB    C3 EDA4        C               JP      ERAFIL1               ;and repeat process
                         C      
                         C               PAGE
''      MACRO-80 3.44   09-Dec-81       PAGE    1-26


                         C      
                         C      ;
                         C      ;   Look through the space allocation map (bit map) for the next available block
                         C      ;   Start searching at block number (BC-1)
                         C      ;   The search procedure is to look for an empty block that is before the starting block
                         C      ;   If not empty, look at a later block number
                         C      ;   In this way, we return the closest empty block on either side of the 'target' block number
                         C      ;   This will speed access on random devices
                         C      ;   For serial devices, this should be changed to look in the forward direction first and then start
                         C      ;     at the front and search some more
                         C      ;
                         C      ;   On return, (DE)= block number that is empty and (HL) =0 if no empty block was found
                         C      ;
  EDBE                   C      FNDSPACE:
  EDBE    50             C               LD      D,B                   ;set (DE) as the block that is checked
  EDBF    59             C               LD      E,C
                         C      ;
                         C      ;   Look before target block
                         C      ;   Registers (BC) are used as the lower pointer and (DE) as the upper pointer
                         C      ;
  EDC0                   C      FNDSPA1:
  EDC0    79             C               LD      A,C                   ;is block 0 specified?
  EDC1    B0             C               OR      B
  EDC2    CA EDD1        C               JP      Z,FNDSPA2
  EDC5    0B             C               DEC     BC                    ;nope, check previous block
  EDC6    D5             C               PUSH    DE
  EDC7    C5             C               PUSH    BC
  EDC8    CD EC35        C               CALL    CKBITMAP
  EDCB    1F             C               RRA                           ;is this block empty?
  EDCC    D2 EDEC        C               JP      NC,FNDSPA3               ;yes. use this
                         C      ;
                         C      ;   Note that the above logic gets the first block that it finds that is empty
                         C      ;   Thus a file could be written 'backward' making it very slow to access
                         C      ;   This could be changed to look for the first empty block and then continue until the start of this
                         C      ;     empty space is located and then used that starting block
                         C      ;   This should help speed up access to some files especially on a well used disk with lots of fairly small 'holes'
                         C      ;
  EDCF    C1             C               POP     BC                    ;nope, check some more
  EDD0    D1             C               POP     DE
                         C      ;
                         C      ;   Now look after target block
                         C      ;
  EDD1                   C      FNDSPA2:
  EDD1    2A F3C6        C               LD      HL,(DSKSIZE)          ;is block (DE) within disk limits?
  EDD4    7B             C               LD      A,E
  EDD5    95             C               SUB     L
  EDD6    7A             C               LD      A,D
  EDD7    9C             C               SBC     A,H
  EDD8    D2 EDF4        C               JP      NC,FNDSPA4
  EDDB    13             C               INC     DE                    ;yes, move on to next one
  EDDC    C5             C               PUSH    BC
  EDDD    D5             C               PUSH    DE
  EDDE    42             C               LD      B,D
  EDDF    4B             C               LD      C,E
  EDE0    CD EC35        C               CALL    CKBITMAP              ;check it
  EDE3    1F             C               RRA                           ;empty?
  EDE4    D2 EDEC        C               JP      NC,FNDSPA3
  EDE7    D1             C               POP     DE                    ;nope, continue searching
  EDE8    C1             C               POP     BC
  EDE9    C3 EDC0        C               JP      FNDSPA1
                         C      ;
                         C      ;   Empty block found
                         C      ;   Set it as used and return with (HL) pointing to it (true?)
                         C      ;
  EDEC                   C      FNDSPA3:
  EDEC    17             C               RLA                           ;reset byte
  EDED    3C             C               INC     A                     ;and set bit 0
  EDEE    CD EC64        C               CALL    STBMAP1               ;update bit map
  EDF1    E1             C               POP     HL                    ;set return registers
  EDF2    D1             C               POP     DE
  EDF3    C9             C               RET
                         C      ;
                         C      ;   Free block was not found
                         C      ;   If (BC) is not zero, then we have not checked all of the disk space
                         C      ;
  EDF4                   C      FNDSPA4:
  EDF4    79             C               LD      A,C
  EDF5    B0             C               OR      B
  EDF6    C2 EDC0        C               JP      NZ,FNDSPA1
  EDF9    21 0000        C               LD      HL,0                  ;set 'not found' status
  EDFC    C9             C               RET
                         C      
''      MACRO-80 3.44   09-Dec-81       PAGE    1-27


                         C               PAGE
''      MACRO-80 3.44   09-Dec-81       PAGE    1-28


                         C      
                         C      ;
                         C      ;   Move a complete fcb entry into the directory and write it
                         C      ;
  EDFD                   C      FCBSET:
  EDFD    0E 00          C               LD      C,0
  EDFF    1E 20          C               LD      E,32                  ;length of each entry
                         C      ;
                         C      ;   Move (E) bytes from the fcb pointed to by (PARAMS) into fcb in directory starting at relative byte (C)
                         C      ;   This updated directory buffer is then written to the disk
                         C      ;
  EE01                   C      UPDATE:
  EE01    D5             C               PUSH    DE
  EE02    06 00          C               LD      B,0                   ;set (BC) to relative byte position
  EE04    2A E943        C               LD      HL,(PARAMS)           ;get address of fcb
  EE07    09             C               ADD     HL,BC                 ;compute starting byte
  EE08    EB             C               EX      DE,HL
  EE09    CD EB5E        C               CALL    FCB2HL                ;get address of fcb to update in directory
  EE0C    C1             C               POP     BC                    ;set (C) to number of bytes to change
  EE0D    CD E94F        C               CALL    DE2HL
  EE10                   C      UPDATE1:
  EE10    CD E9C3        C               CALL    TRKSEC                ;determine the track and sector affected
  EE13    C3 EBC6        C               JP      DIRWRITE              ;then write this sector out
                         C      
                         C      ;
                         C      ;   Routine to change the name of all files on the disk with a specified name
                         C      ;   The fcb contains the current name as the first 12 characters and the new name 16 bytes into the fcb
                         C      ;
  EE16                   C      CHGNAMES:
  EE16    CD EB54        C               CALL    CHKWPRT               ;check for a write protected disk
  EE19    0E 0C          C               LD      C,12                  ;match first 12 bytes of fcb only
  EE1B    CD ED18        C               CALL    FINDFST               ;get first name
  EE1E    2A E943        C               LD      HL,(PARAMS)           ;get address of fcb
  EE21    7E             C               LD      A,(HL)                ;get user number
  EE22    11 0010        C               LD      DE,16                 ;move over to desired name
  EE25    19             C               ADD     HL,DE
  EE26    77             C               LD      (HL),A                ;keep same user number
  EE27                   C      CHGNAM1:
  EE27    CD EBF5        C               CALL    CKFILPOS              ;any matching file found?
  EE2A    C8             C               RET     Z                     ;no, we must be done
  EE2B    CD EB44        C               CALL    CHKROFL               ;check for read only file
  EE2E    0E 10          C               LD      C,16                  ;start 16 bytes into fcb
  EE30    1E 0C          C               LD      E,12                  ;and update the first 12 bytes of directory
  EE32    CD EE01        C               CALL    UPDATE
  EE35    CD ED2D        C               CALL    FINDNXT               ;get the next file name
  EE38    C3 EE27        C               JP      CHGNAM1               ;and continue
                         C      
                         C      ;
                         C      ;   Update a files attributes
                         C      ;   The procedure is to search for every file with the same name as shown in fcb (ignoring bit 7)
                         C      ;     and then to update it (which includes bit 7). No other changes are made
                         C      ;
  EE3B                   C      SAVEATTR:
  EE3B    0E 0C          C               LD      C,12                  ;match first 12 bytes
  EE3D    CD ED18        C               CALL    FINDFST               ;look for first filename
  EE40                   C      SAVATR1:
  EE40    CD EBF5        C               CALL    CKFILPOS              ;was one found?
  EE43    C8             C               RET     Z                     ;nope, we must be done
  EE44    0E 00          C               LD      C,0                   ;yes, update the first 12 bytes now
  EE46    1E 0C          C               LD      E,12
  EE48    CD EE01        C               CALL    UPDATE                ;update filename and write directory
  EE4B    CD ED2D        C               CALL    FINDNXT               ;and get the next file
  EE4E    C3 EE40        C               JP      SAVATR1               ;then continue until done
                         C      
                         C               PAGE
''      MACRO-80 3.44   09-Dec-81       PAGE    1-29


                         C      
                         C      ;
                         C      ;  Open a file (name specified in fcb)
                         C      ;
  EE51                   C      OPENIT:
  EE51    0E 0F          C               LD      C,15                  ;compare the first 15 bytes
  EE53    CD ED18        C               CALL    FINDFST               ;get the first one in directory
  EE56    CD EBF5        C               CALL    CKFILPOS              ;any at all?
  EE59    C8             C               RET     Z
  EE5A                   C      OPENIT1:
  EE5A    CD EAA6        C               CALL    SETEXT                ;point to extent byte within users fcb
  EE5D    7E             C               LD      A,(HL)                ;and get it
  EE5E    F5             C               PUSH    AF                    ;save it and address
  EE5F    E5             C               PUSH    HL
  EE60    CD EB5E        C               CALL    FCB2HL                ;point to fcb in directory
  EE63    EB             C               EX      DE,HL
  EE64    2A E943        C               LD      HL,(PARAMS)           ;this is the users copy
  EE67    0E 20          C               LD      C,32                  ;move it into users space
  EE69    D5             C               PUSH    DE
  EE6A    CD E94F        C               CALL    DE2HL
  EE6D    CD EB78        C               CALL    SETS2B7               ;set bit 7 in 's2' byte (unmodified)
  EE70    D1             C               POP     DE                    ;now get the extent byte from this fcb
  EE71    21 000C        C               LD      HL,12
  EE74    19             C               ADD     HL,DE
  EE75    4E             C               LD      C,(HL)                ;into (C)
  EE76    21 000F        C               LD      HL,15                 ;now get the record count byte into (B)
  EE79    19             C               ADD     HL,DE
  EE7A    46             C               LD      B,(HL)
  EE7B    E1             C               POP     HL                    ;keep the same extent as the user had originally
  EE7C    F1             C               POP     AF
  EE7D    77             C               LD      (HL),A
  EE7E    79             C               LD      A,C                   ;is it the same as in the directory fcb?
  EE7F    BE             C               CP      (HL)
  EE80    78             C               LD      A,B                   ;if yes, then use the same record count
  EE81    CA EE8B        C               JP      Z,OPENIT2
  EE84    3E 00          C               LD      A,0                   ;if the user specified an extent greater than
  EE86    DA EE8B        C               JP      C,OPENIT2             ;the one in the directory, then set record count to 0
  EE89    3E 80          C               LD      A,128                 ;otherwise set to maximum
  EE8B                   C      OPENIT2:
  EE8B    2A E943        C               LD      HL,(PARAMS)           ;set record count in users fcb to (A)
  EE8E    11 000F        C               LD      DE,15
  EE91    19             C               ADD     HL,DE                 ;compute relative position
  EE92    77             C               LD      (HL),A                ;and set the record count
  EE93    C9             C               RET
                         C      
                         C      ;
                         C      ;   Move two bytes from (DE) to (HL) if (and only if) (HL) point to a zero value (16 bit)
                         C      ;   Return with zero flag set it (DE) was moved. Registers (DE); and (HL) are not changed. However (A) is
                         C      ;
  EE94                   C      MOVEWORD:
  EE94    7E             C               LD      A,(HL)                ;check for a zero word
  EE95    23             C               INC     HL
  EE96    B6             C               OR      (HL)                  ;both bytes zero?
  EE97    2B             C               DEC     HL
  EE98    C0             C               RET     NZ                    ;nope, just return
  EE99    1A             C               LD      A,(DE)                ;yes, move two bytes from (DE) into
  EE9A    77             C               LD      (HL),A                ;this zero space
  EE9B    13             C               INC     DE
  EE9C    23             C               INC     HL
  EE9D    1A             C               LD      A,(DE)
  EE9E    77             C               LD      (HL),A
  EE9F    1B             C               DEC     DE                    ;don't disturb these registers
  EEA0    2B             C               DEC     HL
  EEA1    C9             C               RET
                         C      
                         C               PAGE
''      MACRO-80 3.44   09-Dec-81       PAGE    1-30


                         C      
                         C      ;
                         C      ;   Get here to close a file specified by (fcb)
                         C      ;
  EEA2                   C      CLOSEIT:
  EEA2    AF             C               XOR     A                     ;clear status and file position bytes
  EEA3    32 E945        C               LD      (STATUS),A
  EEA6    32 F3EA        C               LD      (FILEPOS),A
  EEA9    32 F3EB        C               LD      (FILEPOS+1),A
  EEAC    CD EB1E        C               CALL    GETWPRT               ;get write protect bit for this drive
  EEAF    C0             C               RET     NZ                    ;just return if it is set
  EEB0    CD EB69        C               CALL    GETS2                 ;else get the 's2' byte
  EEB3    E6 80          C               AND     080H                  ;and look at bit 7 (file unmodified?)
  EEB5    C0             C               RET     NZ                    ;just return if set
  EEB6    0E 0F          C               LD      C,15                  ;else look up this file in directory
  EEB8    CD ED18        C               CALL    FINDFST
  EEBB    CD EBF5        C               CALL    CKFILPOS              ;was it found?
  EEBE    C8             C               RET     Z                     ;just return if not
  EEBF    01 0010        C               LD      BC,16                 ;set (HL) pointing to records used section
  EEC2    CD EB5E        C               CALL    FCB2HL
  EEC5    09             C               ADD     HL,BC
  EEC6    EB             C               EX      DE,HL
  EEC7    2A E943        C               LD      HL,(PARAMS)           ;do the same for users specified fcb
  EECA    09             C               ADD     HL,BC
  EECB    0E 10          C               LD      C,16                  ;this many bytes are present in this extent
  EECD                   C      CLOSEIT1:
  EECD    3A F3DD        C               LD      A,(BIGDISK)           ;8 or 16 bit record numbers?
  EED0    B7             C               OR      A
  EED1    CA EEE8        C               JP      Z,CLOSEIT4
  EED4    7E             C               LD      A,(HL)                ;just 8 bit. Get one from users fcb
  EED5    B7             C               OR      A
  EED6    1A             C               LD      A,(DE)                ;now get one from directory fcb
  EED7    C2 EEDB        C               JP      NZ,CLOSEIT2
  EEDA    77             C               LD      (HL),A                ;users byte was zero. Update from directory
  EEDB                   C      CLOSEIT2:
  EEDB    B7             C               OR      A
  EEDC    C2 EEE1        C               JP      NZ,CLOSEIT3
  EEDF    7E             C               LD      A,(HL)                ;directories byte was zero, update from users fcb
  EEE0    12             C               LD      (DE),A
  EEE1                   C      CLOSEIT3:
  EEE1    BE             C               CP      (HL)                  ;if neither one of these bytes were zero
  EEE2    C2 EF1F        C               JP      NZ,CLOSEIT7           ;then close error if they are not the same
  EEE5    C3 EEFD        C               JP      CLOSEIT5              ;ok so far, get to next byte in fcbs
  EEE8                   C      CLOSEIT4:
  EEE8    CD EE94        C               CALL    MOVEWORD              ;update users fcb if it is zero
  EEEB    EB             C               EX      DE,HL
  EEEC    CD EE94        C               CALL    MOVEWORD              ;update directories fcb if it is zero
  EEEF    EB             C               EX      DE,HL
  EEF0    1A             C               LD      A,(DE)                ;if these two values are no different
  EEF1    BE             C               CP      (HL)                  ;then a close error occured
  EEF2    C2 EF1F        C               JP      NZ,CLOSEIT7
  EEF5    13             C               INC     DE                    ;check second byte
  EEF6    23             C               INC     HL
  EEF7    1A             C               LD      A,(DE)
  EEF8    BE             C               CP      (HL)
  EEF9    C2 EF1F        C               JP      NZ,CLOSEIT7
  EEFC    0D             C               DEC     C                     ;remember 16 bit values
  EEFD                   C      CLOSEIT5:
  EEFD    13             C               INC     DE                    ;bump to next item in table
  EEFE    23             C               INC     HL
  EEFF    0D             C               DEC     C                     ;there are 16 entries only
  EF00    C2 EECD        C               JP      NZ,CLOSEIT1           ;continue if more to do
  EF03    01 FFEC        C               LD      BC,0FFECH             ;backup 20 places (extent byte)
  EF06    09             C               ADD     HL,BC
  EF07    EB             C               EX      DE,HL
  EF08    09             C               ADD     HL,BC
  EF09    1A             C               LD      A,(DE)
  EF0A    BE             C               CP      (HL)                  ;directory's extent already greater than the
  EF0B    DA EF17        C               JP      C,CLOSEIT6            ;users extent?
  EF0E    77             C               LD      (HL),A                ;no, update directory extent
  EF0F    01 0003        C               LD      BC,3                  ;and update the record count byte in
  EF12    09             C               ADD     HL,BC                 ;directories fcb
  EF13    EB             C               EX      DE,HL
  EF14    09             C               ADD     HL,BC
  EF15    7E             C               LD      A,(HL)                ;get from user
  EF16    12             C               LD      (DE),A                ;and put in directory
  EF17                   C      CLOSEIT6:
  EF17    3E FF          C               LD      A,0FFH                ;set 'was open and is now closed' byte
  EF19    32 F3D2        C               LD      (CLOSEFLG),A
  EF1C    C3 EE10        C               JP      UPDATE1               ;update the directory now
  EF1F                   C      CLOSEIT7:
  EF1F    21 E945        C               LD      HL,STATUS             ;set return status and then return
''      MACRO-80 3.44   09-Dec-81       PAGE    1-31


  EF22    35             C               DEC     (HL)
  EF23    C9             C               RET
                         C      
                         C               PAGE
''      MACRO-80 3.44   09-Dec-81       PAGE    1-32


                         C      
                         C      ;
                         C      ;   Routine to get the next empty space in the directory
                         C      ;   It will then be cleared for use.
                         C      ;
  EF24                   C      GETEMPTY:
  EF24    CD EB54        C               CALL    CHKWPRT               ;make sure disk is not write protected
  EF27    2A E943        C               LD      HL,(PARAMS)           ;save current parameters (fcb)
  EF2A    E5             C               PUSH    HL
  EF2B    21 F3AC        C               LD      HL,EMPTYFCB           ;use special one for empty space
  EF2E    22 E943        C               LD      (PARAMS),HL
  EF31    0E 01          C               LD      C,1                   ;search for first empty spot in directory
  EF33    CD ED18        C               CALL    FINDFST               ;(* only check first byte *)
  EF36    CD EBF5        C               CALL    CKFILPOS              ;none?
  EF39    E1             C               POP     HL
  EF3A    22 E943        C               LD      (PARAMS),HL           ;restore original fcb address
  EF3D    C8             C               RET     Z                     ;return if no more space
  EF3E    EB             C               EX      DE,HL
  EF3F    21 000F        C               LD      HL,15                 ;point to number of records for this file
  EF42    19             C               ADD     HL,DE
  EF43    0E 11          C               LD      C,17                  ;and clear all of this space
  EF45    AF             C               XOR     A
  EF46                   C      GETMT1:
  EF46    77             C               LD      (HL),A
  EF47    23             C               INC     HL
  EF48    0D             C               DEC     C
  EF49    C2 EF46        C               JP      NZ,GETMT1
  EF4C    21 000D        C               LD      HL,13                 ;clear the 's1' byte also
  EF4F    19             C               ADD     HL,DE
  EF50    77             C               LD      (HL),A
  EF51    CD EB8C        C               CALL    CHKNMBR               ;keep (SCRATCH1) within bounds
  EF54    CD EDFD        C               CALL    FCBSET                ;write out this fcb entry to directory
  EF57    C3 EB78        C               JP      SETS2B7               ;set 's2' byte bit 7 (unmodified at present)
                         C      
                         C               PAGE
''      MACRO-80 3.44   09-Dec-81       PAGE    1-33


                         C      
                         C      ;
                         C      ;   Routine to close the current extent and open the next one for reading
                         C      ;
  EF5A                   C      GETNEXT:
  EF5A    AF             C               XOR     A
  EF5B    32 F3D2        C               LD      (CLOSEFLG),A          ;clear close flag
  EF5E    CD EEA2        C               CALL    CLOSEIT               ;close this extent
  EF61    CD EBF5        C               CALL    CKFILPOS
  EF64    C8             C               RET     Z                     ;not there?
  EF65    2A E943        C               LD      HL,(PARAMS)           ;get extent byte
  EF68    01 000C        C               LD      BC,12
  EF6B    09             C               ADD     HL,BC
  EF6C    7E             C               LD      A,(HL)                ;and increment it
  EF6D    3C             C               INC     A
  EF6E    E6 1F          C               AND     01FH                  ;keep within range 0-31
  EF70    77             C               LD      (HL),A
  EF71    CA EF83        C               JP      Z,GTNEXT1             ;overflow?
  EF74    47             C               LD      B,A                   ;mask extent byte
  EF75    3A F3C5        C               LD      A,(EXTMASK)
  EF78    A0             C               AND     B
  EF79    21 F3D2        C               LD      HL,CLOSEFLG           ;check close flag (0ffh is ok)
  EF7C    A6             C               AND     (HL)
  EF7D    CA EF8E        C               JP      Z,GTNEXT2             ;if zero, we must read in next extent
  EF80    C3 EFAC        C               JP      GTNEXT3               ;else, it is already in memory
  EF83                   C      GTNEXT1:
  EF83    01 0002        C               LD      BC,2                  ;Point to the 's2' byte
  EF86    09             C               ADD     HL,BC
  EF87    34             C               INC     (HL)                  ;and bump it
  EF88    7E             C               LD      A,(HL)                ;too many extents?
  EF89    E6 0F          C               AND     00FH
  EF8B    CA EFB6        C               JP      Z,GTNEXT5             ;yes, set error code
                         C      ;
                         C      ;   Get here to open the next extent
                         C      ;
  EF8E                   C      GTNEXT2:
  EF8E    0E 0F          C               LD      C,15                  ;set to check first 15 bytes of fcb
  EF90    CD ED18        C               CALL    FINDFST               ;find the first one
  EF93    CD EBF5        C               CALL    CKFILPOS              ;none available?
  EF96    C2 EFAC        C               JP      NZ,GTNEXT3
  EF99    3A F3D3        C               LD      A,(RDWRTFLG)          ;no extent present. Can we open an empty one?
  EF9C    3C             C               INC     A                     ;0ffh means reading (so not possible)
  EF9D    CA EFB6        C               JP      Z,GTNEXT5             ;or an error
  EFA0    CD EF24        C               CALL    GETEMPTY              ;we are writing, get an empty entry
  EFA3    CD EBF5        C               CALL    CKFILPOS              ;none?
  EFA6    CA EFB6        C               JP      Z,GTNEXT5             ;error if true
  EFA9    C3 EFAF        C               JP      GTNEXT4               ;else we are almost done
  EFAC                   C      GTNEXT3:
  EFAC    CD EE5A        C               CALL    OPENIT1               ;open this extent
  EFAF                   C      GTNEXT4:
  EFAF    CD EABB        C               CALL    STRDATA               ;move in updated data (rec #, extent #, etc.)
  EFB2    AF             C               XOR     A                     ;clear status and return
  EFB3    C3 E901        C               JP      SETSTAT
                         C      ;
                         C      ;   Error in extending the file
                         C      ;   Too many extents were needed or not enough space on the disk
                         C      ;
  EFB6                   C      GTNEXT5:
  EFB6    CD E905        C               CALL    IOERR1                ;set error code, clear bit 7 of 's2'
  EFB9    C3 EB78        C               JP      SETS2B7               ;so this is not written on a close
                         C      
                         C               PAGE
''      MACRO-80 3.44   09-Dec-81       PAGE    1-34


                         C      
                         C      ;
                         C      ;   Read a sequential file
                         C      ;
  EFBC                   C      RDSEQ:
  EFBC    3E 01          C               LD      A,1                   ;set sequential access mode
  EFBE    32 F3D5        C               LD      (MODE),A
  EFC1                   C      RDSEQ1:
  EFC1    3E FF          C               LD      A,0FFH                ;don't allow reading unwritten space
  EFC3    32 F3D3        C               LD      (RDWRTFLG),A
  EFC6    CD EABB        C               CALL    STRDATA               ;put rec# and ext# into fcb
  EFC9    3A F3E3        C               LD      A,(SAVNREC)           ;get next record to read
  EFCC    21 F3E1        C               LD      HL,SAVNXT             ;get number of records in extent
  EFCF    BE             C               CP      (HL)                  ;within this extent?
  EFD0    DA EFE6        C               JP      C,RDSEQ2
  EFD3    FE 80          C               CP      128                   ;no. Is this extent fully used?
  EFD5    C2 EFFB        C               JP      NZ,RDSEQ3             ;no. End-of-file
  EFD8    CD EF5A        C               CALL    GETNEXT               ;yes, open the next one
  EFDB    AF             C               XOR     A                     ;reset next record to read
  EFDC    32 F3E3        C               LD      (SAVNREC),A
  EFDF    3A E945        C               LD      A,(STATUS)            ;check on open, successful?
  EFE2    B7             C               OR      A
  EFE3    C2 EFFB        C               JP      NZ,RDSEQ3             ;no, error
  EFE6                   C      RDSEQ2:
  EFE6    CD EA77        C               CALL    COMBLK                ;ok. compute block number to read
  EFE9    CD EA84        C               CALL    CHKBLK                ;check it. Within bounds?
  EFEC    CA EFFB        C               JP      Z,RDSEQ3              ;no, error
  EFEF    CD EA8A        C               CALL    LOGICAL               ;convert (BLKNMBR) to logical sector (128 byte)
  EFF2    CD E9D1        C               CALL    TRKSEC1               ;set the track and sector for this block #
  EFF5    CD E9B2        C               CALL    DOREAD                ;and read it
  EFF8    C3 EAD2        C               JP      SETNREC               ;and set the next record to be accessed
                         C      ;
                         C      ;   Read error occured. Set status and return
                         C      ;
  EFFB                   C      RDSEQ3:
  EFFB    C3 E905        C               JP      IOERR1
                         C      
                         C               PAGE
''      MACRO-80 3.44   09-Dec-81       PAGE    1-35


                         C      
                         C      ;
                         C      ;   Write the next sequential record
                         C      ;
  EFFE                   C      WTSEQ:
  EFFE    3E 01          C               LD      A,1                   ;set sequential access mode
  F000    32 F3D5        C               LD      (MODE),A
  F003                   C      WTSEQ1:
  F003    3E 00          C               LD      A,0                   ;allow an addition empty extent to be opened
  F005    32 F3D3        C               LD      (RDWRTFLG),A
  F008    CD EB54        C               CALL    CHKWPRT               ;check write protect status
  F00B    2A E943        C               LD      HL,(PARAMS)
  F00E    CD EB47        C               CALL    CKROF1                ;check for read only file, (HL) already set to fcb
  F011    CD EABB        C               CALL    STRDATA               ;put updated data into fcb
  F014    3A F3E3        C               LD      A,(SAVNREC)           ;get record number to write
  F017    FE 80          C               CP      128                   ;within range?
  F019    D2 E905        C               JP      NC,IOERR1             ;no, error(?)
  F01C    CD EA77        C               CALL    COMBLK                ;compute block number
  F01F    CD EA84        C               CALL    CHKBLK                ;check number
  F022    0E 00          C               LD      C,0                   ;is there one to write to?
  F024    C2 F06E        C               JP      NZ,WTSEQ6             ;yes, go do it
  F027    CD EA3E        C               CALL    GETBLOCK              ;get next block number within fcb to use
  F02A    32 F3D7        C               LD      (RELBLOCK),A          ;and save
  F02D    01 0000        C               LD      BC,0                  ;start looking for space from the start
  F030    B7             C               OR      A                     ;if none allocated as yet
  F031    CA F03B        C               JP      Z,WTSEQ2
  F034    4F             C               LD      C,A                   ;extract previous block number from fcb
  F035    0B             C               DEC     BC                    ;so we can be closest to it
  F036    CD EA5E        C               CALL    EXTBLK
  F039    44             C               LD      B,H
  F03A    4D             C               LD      C,L
  F03B                   C      WTSEQ2:
  F03B    CD EDBE        C               CALL    FNDSPACE              ;find the next empty block nearest number (BC)
  F03E    7D             C               LD      A,L                   ;check for a zero number
  F03F    B4             C               OR      H
  F040    C2 F048        C               JP      NZ,WTSEQ3
  F043    3E 02          C               LD      A,2                   ;no more space?
  F045    C3 E901        C               JP      SETSTAT
  F048                   C      WTSEQ3:
  F048    22 F3E5        C               LD      (BLKNMBR),HL          ;save block number to access
  F04B    EB             C               EX      DE,HL                 ;put block number into (DE)
  F04C    2A E943        C               LD      HL,(PARAMS)           ;now we must update the fcb for this
  F04F    01 0010        C               LD      BC,16                 ;newly allocated block
  F052    09             C               ADD     HL,BC
  F053    3A F3DD        C               LD      A,(BIGDISK)           ;8 or 16 bit block numbers?
  F056    B7             C               OR      A
  F057    3A F3D7        C               LD      A,(RELBLOCK)          ;(* update this entry *)
  F05A    CA F064        C               JP      Z,WTSEQ4              ;zero means 16 bit ones
  F05D    CD EB64        C               CALL    ADDA2HL               ;(HL)=(HL)+(A)
  F060    73             C               LD      (HL),E                ;store new block number
  F061    C3 F06C        C               JP      WTSEQ5
  F064                   C      WTSEQ4:
  F064    4F             C               LD      C,A                   ;compute spot in this 16 bit table
  F065    06 00          C               LD      B,0
  F067    09             C               ADD     HL,BC
  F068    09             C               ADD     HL,BC
  F069    73             C               LD      (HL),E                ;stuff block number (DE) there
  F06A    23             C               INC     HL
  F06B    72             C               LD      (HL),D
  F06C                   C      WTSEQ5:
  F06C    0E 02          C               LD      C,2                   ;set (C) to indicate writing to un-used disk space
  F06E                   C      WTSEQ6:
  F06E    3A E945        C               LD      A,(STATUS)            ;are we ok so far?
  F071    B7             C               OR      A
  F072    C0             C               RET     NZ
  F073    C5             C               PUSH    BC                    ;yes, save write flag for bios (register C)
  F074    CD EA8A        C               CALL    LOGICAL               ;convert (BLKNMBR) over to loical sectors
  F077    3A F3D5        C               LD      A,(MODE)              ;get access mode flag (1=sequential, 0=random, 2=special?)
  F07A    3D             C               DEC     A
  F07B    3D             C               DEC     A
  F07C    C2 F0BB        C               JP      NZ,WTSEQ9
                         C      ;
                         C      ;   Special random i/o from function #40
                         C      ;   Maybe for M/PM, but the current block, if it has not been written to, will be zeroed out and then written (reason?)
                         C      ;
  F07F    C1             C               POP     BC
  F080    C5             C               PUSH    BC
  F081    79             C               LD      A,C                   ;get write status flag (2=writing unused space)
  F082    3D             C               DEC     A
  F083    3D             C               DEC     A
  F084    C2 F0BB        C               JP      NZ,WTSEQ9
  F087    E5             C               PUSH    HL
''      MACRO-80 3.44   09-Dec-81       PAGE    1-36


  F088    2A F3B9        C               LD      HL,(DIRBUF)           ;zero out the directory buffer
  F08B    57             C               LD      D,A                   ;note that (A) is zero here
  F08C                   C      WTSEQ7:
  F08C    77             C               LD      (HL),A
  F08D    23             C               INC     HL
  F08E    14             C               INC     D                     ;do 128 bytes
  F08F    F2 F08C        C               JP      P,WTSEQ7
  F092    CD EBE0        C               CALL    DIRDMA                ;tell the bios the dma address for directory access
  F095    2A F3E7        C               LD      HL,(LOGSECT)          ;get sector that starts current block
  F098    0E 02          C               LD      C,2                   ;set 'writing to unused space' flag
  F09A                   C      WTSEQ8:
  F09A    22 F3E5        C               LD      (BLKNMBR),HL          ;save sector to write
  F09D    C5             C               PUSH    BC
  F09E    CD E9D1        C               CALL    TRKSEC1               ;determine its track and sector numbers
  F0A1    C1             C               POP     BC
  F0A2    CD E9B8        C               CALL    DOWRITE               ;now write out 128 bytes of zeros
  F0A5    2A F3E5        C               LD      HL,(BLKNMBR)          ;get sector number
  F0A8    0E 00          C               LD      C,0                   ;set normal write flag
  F0AA    3A F3C4        C               LD      A,(BLKMASK)           ;determine if we have written the entire
  F0AD    47             C               LD      B,A                   ;physical block
  F0AE    A5             C               AND     L
  F0AF    B8             C               CP      B
  F0B0    23             C               INC     HL                    ;prepare for the next one
  F0B1    C2 F09A        C               JP      NZ,WTSEQ8             ;continue until (BLKMASK+1) sectors written
  F0B4    E1             C               POP     HL                    ;reset next sector number
  F0B5    22 F3E5        C               LD      (BLKNMBR),HL
  F0B8    CD EBDA        C               CALL    DEFDMA                ;and reset dma address
                         C      ;
                         C      ;   Normal disk write
                         C      ;   Set the desired track and sector then do the actual write
                         C      ;
  F0BB                   C      WTSEQ9:
  F0BB    CD E9D1        C               CALL    TRKSEC1               ;determine track and sector for this write
  F0BE    C1             C               POP     BC                    ;get write status flag
  F0BF    C5             C               PUSH    BC
  F0C0    CD E9B8        C               CALL    DOWRITE               ;and write this out
  F0C3    C1             C               POP     BC
  F0C4    3A F3E3        C               LD      A,(SAVNREC)           ;get number of records in file
  F0C7    21 F3E1        C               LD      HL,SAVNXT             ;get last record written
  F0CA    BE             C               CP      (HL)
  F0CB    DA F0D2        C               JP      C,WTSEQ10
  F0CE    77             C               LD      (HL),A                ;we have to update record count
  F0CF    34             C               INC     (HL)
  F0D0    0E 02          C               LD      C,2
                         C      ;
                         C      ;*  This area has been patched to correct disk update problem
                         C      ;*    when using blocking and de-blocking in the BIOS
                         C      ;
  F0D2                   C      WTSEQ10:
  F0D2    0D             C               DEC     C
  F0D3    0D             C               DEC     C
  F0D4    C2 F0DF        C               JP      NZ,WTSEQ99
                         C              ;  NOP                           ;was DEC     C
                         C              ;  NOP                           ;ws  DEC     C
                         C              ;  LD      HL,0                  ;was JP      NZ,WTSEQ99
                         C      ;
                         C      ;*  End of patch
                         C      ;
  F0D7    F5             C               PUSH    AF
  F0D8    CD EB69        C               CALL    GETS2                 ;set 'extent written to' flag
  F0DB    E6 7F          C               AND     07FH                  ;(* clear bit 7 *)
  F0DD    77             C               LD      (HL),A
  F0DE    F1             C               POP     AF                    ;get record count for this extent
  F0DF                   C      WTSEQ99:
  F0DF    FE 7F          C               CP      127                   ;is it full?
  F0E1    C2 F100        C               JP      NZ,WTSEQ12
  F0E4    3A F3D5        C               LD      A,(MODE)              ;yes, are we in sequential mode?
  F0E7    FE 01          C               CP      1
  F0E9    C2 F100        C               JP      NZ,WTSEQ12
  F0EC    CD EAD2        C               CALL    SETNREC               ;yes, set next record number
  F0EF    CD EF5A        C               CALL    GETNEXT               ;and get next empty space in directory
  F0F2    21 E945        C               LD      HL,STATUS             ;ok?
  F0F5    7E             C               LD      A,(HL)
  F0F6    B7             C               OR      A
  F0F7    C2 F0FE        C               JP      NZ,WTSEQ11
  F0FA    3D             C               DEC     A                     ;yes, set record count to -1
  F0FB    32 F3E3        C               LD      (SAVNREC),A
  F0FE                   C      WTSEQ11:
  F0FE    36 00          C               LD      (HL),0                ;clear status
  F100                   C      WTSEQ12:
  F100    C3 EAD2        C               JP      SETNREC               ;set next record to access
                         C      ;
                         C      ;   For random i/o, set the fcb for the desired record number based on the 'r0,r1,r2' bytes
''      MACRO-80 3.44   09-Dec-81       PAGE    1-37


                         C      ;   These bytes in the fcb are used as follows:
                         C      ;
                         C      ;       fcb+35            fcb+34            fcb+33
                         C      ;  |     'r-2'      |      'r-1'      |      'r-0'     |
                         C      ;  |7             0 | 7             0 | 7             0|
                         C      ;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
                         C      ;  |    overflow   | | extra |  extent   |   record #  |
                         C      ;  | ______________| |_extent|__number___|_____________|
                         C      ;                     also 's2'
                         C      ;
                         C      ;   On entry, register (C) contains 0ffh if this is a read and thus we can not access unwritten disk space
                         C      ;   Otherwise, another extent will be opened (for writing) if required
                         C      ;
  F103                   C      POSITION:
  F103    AF             C               XOR     A                     ;set random i/o flag
  F104    32 F3D5        C               LD      (MODE),A
                         C      ;
                         C      ;   Special entry (function #40). M/PM ?
                         C      ;
  F107                   C      POSITN1:
  F107    C5             C               PUSH    BC                    ;save read/write flag
  F108    2A E943        C               LD      HL,(PARAMS)           ;get address of fcb
  F10B    EB             C               EX      DE,HL
  F10C    21 0021        C               LD      HL,33                 ;now get byte 'r0'
  F10F    19             C               ADD     HL,DE
  F110    7E             C               LD      A,(HL)
  F111    E6 7F          C               AND     07FH                  ;keep bits 0-6 for the record number to access
  F113    F5             C               PUSH    AF
  F114    7E             C               LD      A,(HL)                ;now get bit 7 of 'r0' and bits 0-3 of 'r1'
  F115    17             C               RLA
  F116    23             C               INC     HL
  F117    7E             C               LD      A,(HL)
  F118    17             C               RLA
  F119    E6 1F          C               AND     01FH                  ;and save this in bits 0-4 of (C)
  F11B    4F             C               LD      C,A                   ;this is the extent byte
  F11C    7E             C               LD      A,(HL)                ;now get the extra extent byte
  F11D    1F             C               RRA
  F11E    1F             C               RRA
  F11F    1F             C               RRA
  F120    1F             C               RRA
  F121    E6 0F          C               AND     00FH
  F123    47             C               LD      B,A                   ;and save it in (B)
  F124    F1             C               POP     AF                    ;get record number back to (A)
  F125    23             C               INC     HL                    ;check overflow byte 'r2'
  F126    6E             C               LD      L,(HL)
  F127    2C             C               INC     L
  F128    2D             C               DEC     L
  F129    2E 06          C               LD      L,6                   ;prepare for error
  F12B    C2 F18B        C               JP      NZ,POSITN5            ;out of disk space error
  F12E    21 0020        C               LD      HL,32                 ;store record number into fcb
  F131    19             C               ADD     HL,DE
  F132    77             C               LD      (HL),A
  F133    21 000C        C               LD      HL,12                 ;and now check the extent byte
  F136    19             C               ADD     HL,DE
  F137    79             C               LD      A,C
  F138    96             C               SUB     (HL)                  ;same extent as before?
  F139    C2 F147        C               JP      NZ,POSITN2
  F13C    21 000E        C               LD      HL,14                 ;yes, check extra extent byte 's2' also
  F13F    19             C               ADD     HL,DE
  F140    78             C               LD      A,B
  F141    96             C               SUB     (HL)
  F142    E6 7F          C               AND     07FH
  F144    CA F17F        C               JP      Z,POSITN3             ;same, we are almost done then
                         C      ;
                         C      ;  Get here when another extent is required
                         C      ;
  F147                   C      POSITN2:
  F147    C5             C               PUSH    BC
  F148    D5             C               PUSH    DE
  F149    CD EEA2        C               CALL    CLOSEIT               ;close current extent
  F14C    D1             C               POP     DE
  F14D    C1             C               POP     BC
  F14E    2E 03          C               LD      L,3                   ;prepare for error
  F150    3A E945        C               LD      A,(STATUS)
  F153    3C             C               INC     A
  F154    CA F184        C               JP      Z,POSITN4             ;close error
  F157    21 000C        C               LD      HL,12                 ;put desired extent into fcb now
  F15A    19             C               ADD     HL,DE
  F15B    71             C               LD      (HL),C
  F15C    21 000E        C               LD      HL,14                 ;and store extra extent byte 's2'
  F15F    19             C               ADD     HL,DE
  F160    70             C               LD      (HL),B
  F161    CD EE51        C               CALL    OPENIT                ;try and get this extent
''      MACRO-80 3.44   09-Dec-81       PAGE    1-38


  F164    3A E945        C               LD      A,(STATUS)            ;was it there?
  F167    3C             C               INC     A
  F168    C2 F17F        C               JP      NZ,POSITN3
  F16B    C1             C               POP     BC                    ;no. can we create a new one (writing?)
  F16C    C5             C               PUSH    BC
  F16D    2E 04          C               LD      L,4                   ;prepare for error
  F16F    0C             C               INC     C
  F170    CA F184        C               JP      Z,POSITN4             ;nope, reading unwritten space error
  F173    CD EF24        C               CALL    GETEMPTY              ;yes we can, try to find space
  F176    2E 05          C               LD      L,5                   ;prepare for error
  F178    3A E945        C               LD      A,(STATUS)
  F17B    3C             C               INC     A
  F17C    CA F184        C               JP      Z,POSITN4             ;out of space?
                         C      ;
                         C      ;   Normal return location. Clear error code and return
                         C      ;
  F17F                   C      POSITN3:
  F17F    C1             C               POP     BC                    ;restore stack
  F180    AF             C               XOR     A                     ;and clear error code byte
  F181    C3 E901        C               JP      SETSTAT
                         C      ;
                         C      ;   Error. Set the 's2' byte to indicate this (why?)
                         C      ;
  F184                   C      POSITN4:
  F184    E5             C               PUSH    HL
  F185    CD EB69        C               CALL    GETS2
  F188    36 C0          C               LD      (HL),0C0H
  F18A    E1             C               POP     HL
                         C      ;
                         C      ;   Return with error code (presently in L)
                         C      ;
  F18B                   C      POSITN5:
  F18B    C1             C               POP     BC
  F18C    7D             C               LD      A,L                   ;get error code
  F18D    32 E945        C               LD      (STATUS),A
  F190    C3 EB78        C               JP      SETS2B7
                         C      
                         C               PAGE
''      MACRO-80 3.44   09-Dec-81       PAGE    1-39


                         C      
                         C      ;
                         C      ;   Read a random record
                         C      ;
  F193                   C      READRAN:
  F193    0E FF          C               LD      C,0FFH                ;set 'read' status
  F195    CD F103        C               CALL    POSITION              ;position the file to proper record
  F198    CC EFC1        C               CALL    Z,RDSEQ1              ;and read it as usual (if no errors)
  F19B    C9             C               RET
                         C      
                         C      ;
                         C      ;   Write to a random record
                         C      ;
  F19C                   C      WRITERAN:
  F19C    0E 00          C               LD      C,0                   ;set 'writing' flag
  F19E    CD F103        C               CALL    POSITION              ;position the file to proper record
  F1A1    CC F003        C               CALL    Z,WTSEQ1              ;and write as usual (if no errors)
  F1A4    C9             C               RET
                         C      
                         C      ;
                         C      ;   Compute the random record number
                         C      ;   Enter with (HL) pointing to a fcb an (DE) contains a relative location of a record number
                         C      ;   On exit, (C) contains the 'r0' byte, (B) the 'r1' byte, and (A) the 'r2' byte
                         C      ;
                         C      ;   On return, the zero flag is set if the record is within bounds
                         C      ;   Otherwise, an overflow occured
                         C      ;
  F1A5                   C      COMPRAND:
  F1A5    EB             C               EX      DE,HL                 ;save fcb pointer in (DE)
  F1A6    19             C               ADD     HL,DE                 ;compute relative position of record #
  F1A7    4E             C               LD      C,(HL)                ;get record number into (BC)
  F1A8    06 00          C               LD      B,0
  F1AA    21 000C        C               LD      HL,12                 ;now get extent
  F1AD    19             C               ADD     HL,DE
  F1AE    7E             C               LD      A,(HL)                ;compute (BC)=(record #)+(extent)*128
  F1AF    0F             C               RRCA                          ;move lower bit into bit 7
  F1B0    E6 80          C               AND     080H                  ;and ignore all other bits
  F1B2    81             C               ADD     A,C                   ;add to our record number
  F1B3    4F             C               LD      C,A
  F1B4    3E 00          C               LD      A,0                   ;take care of any carry
  F1B6    88             C               ADC     A,B
  F1B7    47             C               LD      B,A
  F1B8    7E             C               LD      A,(HL)                ;now get the upper bits of extent into
  F1B9    0F             C               RRCA                          ;bit positions 0-3
  F1BA    E6 0F          C               AND     00FH                  ;and ignore all others
  F1BC    80             C               ADD     A,B                   ;add this in to 'r1' byte
  F1BD    47             C               LD      B,A
  F1BE    21 000E        C               LD      HL,14                 ;get the 's2' byte (extra extent)
  F1C1    19             C               ADD     HL,DE
  F1C2    7E             C               LD      A,(HL)
  F1C3    87             C               ADD     A,A                   ;and shift it left 4 bits (bits 4-7)
  F1C4    87             C               ADD     A,A
  F1C5    87             C               ADD     A,A
  F1C6    87             C               ADD     A,A
  F1C7    F5             C               PUSH    AF                    ;save carry flag (bit 0 of flag byte)
  F1C8    80             C               ADD     A,B                   ;now add extra extent into 'r1'
  F1C9    47             C               LD      B,A
  F1CA    F5             C               PUSH    AF                    ;and save carry (overflow byte 'r2')
  F1CB    E1             C               POP     HL                    ;bit 0 of (L) is the overflow indicator
  F1CC    7D             C               LD      A,L
  F1CD    E1             C               POP     HL                    ;and same for first carry flag
  F1CE    B5             C               OR      L                     ;either one of these set?
  F1CF    E6 01          C               AND     001H                  ;only check the carry flags
  F1D1    C9             C               RET
                         C      
                         C      ;
                         C      ;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to reflect the last record used for a random (or other) file
                         C      ;   This reads the directory and looks at all extents computing the largerst record number for each and keeping the maximum value o
                         C      ;   Then 'r0', 'r1', and 'r2' will reflect this maximum record number
                         C      ;   This is used to compute the space used by a random file
                         C      ;
  F1D2                   C      RANSIZE:
  F1D2    0E 0C          C               LD      C,12                  ;look thru directory for first entry with
  F1D4    CD ED18        C               CALL    FINDFST               ;this name
  F1D7    2A E943        C               LD      HL,(PARAMS)           ;zero out the 'r0, r1, r2' bytes
  F1DA    11 0021        C               LD      DE,21H
  F1DD    19             C               ADD     HL,DE
  F1DE    E5             C               PUSH    HL
  F1DF    72             C               LD      (HL),D                ;note that (D)=0
  F1E0    23             C               INC     HL
  F1E1    72             C               LD      (HL),D
  F1E2    23             C               INC     HL
''      MACRO-80 3.44   09-Dec-81       PAGE    1-40


  F1E3    72             C               LD      (HL),D
  F1E4                   C      RANSIZ1:
  F1E4    CD EBF5        C               CALL    CKFILPOS              ;is there an extent to process?
  F1E7    CA F20C        C               JP      Z,RANSIZ3             ;no, we are done
  F1EA    CD EB5E        C               CALL    FCB2HL                ;set (HL) pointing to proper fcb in dir
  F1ED    11 000F        C               LD      DE,15                 ;point to last record in extent
  F1F0    CD F1A5        C               CALL    COMPRAND              ;and compute random parameters
  F1F3    E1             C               POP     HL
  F1F4    E5             C               PUSH    HL                    ;now check these values against those
  F1F5    5F             C               LD      E,A                   ;already in fcb
  F1F6    79             C               LD      A,C                   ;the carry flag will be set if those
  F1F7    96             C               SUB     (HL)                  ;in the fcb represent a larger size than
  F1F8    23             C               INC     HL                    ;this extent does
  F1F9    78             C               LD      A,B
  F1FA    9E             C               SBC     A,(HL)
  F1FB    23             C               INC     HL
  F1FC    7B             C               LD      A,E
  F1FD    9E             C               SBC     A,(HL)
  F1FE    DA F206        C               JP      C,RANSIZ2
  F201    73             C               LD      (HL),E                ;we found a larger (in size) extent
  F202    2B             C               DEC     HL                    ;stuff these values into fcb
  F203    70             C               LD      (HL),B
  F204    2B             C               DEC     HL
  F205    71             C               LD      (HL),C
  F206                   C      RANSIZ2:
  F206    CD ED2D        C               CALL    FINDNXT               ;now get the next extent
  F209    C3 F1E4        C               JP      RANSIZ1               ;continue til all done
  F20C                   C      RANSIZ3:
  F20C    E1             C               POP     HL                    ;we are done, restore the stack and
  F20D    C9             C               RET                           ;return
                         C      
                         C               PAGE
''      MACRO-80 3.44   09-Dec-81       PAGE    1-41


                         C      
                         C      ;
                         C      ;   Function to return the random record position of a given file which has been read in sequential mode up to now
                         C      ;
  F20E                   C      SETRAN:
  F20E    2A E943        C               LD      HL,(PARAMS)           ;point to fcb
  F211    11 0020        C               LD      DE,32                 ;and to last used record
  F214    CD F1A5        C               CALL    COMPRAND              ;compute random position
  F217    21 0021        C               LD      HL,33                 ;now stuff these values into fcb
  F21A    19             C               ADD     HL,DE
  F21B    71             C               LD      (HL),C                ;move 'r0'
  F21C    23             C               INC     HL
  F21D    70             C               LD      (HL),B                ;and 'r1'
  F21E    23             C               INC     HL
  F21F    77             C               LD      (HL),A                ;and lastly 'r2'
  F220    C9             C               RET
                         C      
                         C      ;
                         C      ;   This routine select the drive specified in (ACTIVE)
                         C      ;     and update the login vector and bitmap table if this drive was not already active
                         C      ;
  F221                   C      LOGINDRV:
  F221    2A F3AF        C               LD      HL,(LOGIN)            ;get the login vector
  F224    3A E942        C               LD      A,(ACTIVE)            ;get the default drive
  F227    4F             C               LD      C,A
  F228    CD EAEA        C               CALL    SHIFTR                ;position active bit for this drive
  F22B    E5             C               PUSH    HL                    ;into bit 0
  F22C    EB             C               EX      DE,HL
  F22D    CD E959        C               CALL    SELECT                ;select this drive
  F230    E1             C               POP     HL
  F231    CC E947        C               CALL    Z,SLCTERR             ;valid drive?
  F234    7D             C               LD      A,L                   ;is this a newly activated drive?
  F235    1F             C               RRA
  F236    D8             C               RET     C
  F237    2A F3AF        C               LD      HL,(LOGIN)            ;yes, update the login vector
  F23A    4D             C               LD      C,L
  F23B    44             C               LD      B,H
  F23C    CD EB0B        C               CALL    SETBIT
  F23F    22 F3AF        C               LD      (LOGIN),HL            ;and save
  F242    C3 ECA3        C               JP      BITMAP                ;now update the bitmap
                         C      
                         C      ;
                         C      ;   Function to set the active disk number
                         C      ;
  F245                   C      SETDSK:
  F245    3A F3D6        C               LD      A,(EPARAM)            ;get parameter passed and see if this
  F248    21 E942        C               LD      HL,ACTIVE             ;represents a change in drives
  F24B    BE             C               CP      (HL)
  F24C    C8             C               RET     Z
  F24D    77             C               LD      (HL),A                ;yes it does, log it in
  F24E    C3 F221        C               JP      LOGINDRV
                         C      
                         C      ;
                         C      ;   This is the 'auto disk select' routine
                         C      ;   The firsst byte of the fcb is examined for a drive specification
                         C      ;   If non zero then the drive will be selected and loged in
                         C      ;
  F251                   C      AUTOSEL:
  F251    3E FF          C               LD      A,0FFH                ;say 'auto-select activated'
  F253    32 F3DE        C               LD      (AUTO),A
  F256    2A E943        C               LD      HL,(PARAMS)           ;get drive specified
  F259    7E             C               LD      A,(HL)
  F25A    E6 1F          C               AND     01FH                  ;look at lower 5 bits
  F25C    3D             C               DEC     A                     ;adjust for (1=A, 2=B) etc
  F25D    32 F3D6        C               LD      (EPARAM),A            ;and save for the select routine
  F260    FE 1E          C               CP      01EH                  ;check for 'no change' condition
  F262    D2 F275        C               JP      NC,AUTOSL1            ;yes, don't change
  F265    3A E942        C               LD      A,(ACTIVE)            ;we must change, save currently active
  F268    32 F3DF        C               LD      (OLDDRV),A            ;drive
  F26B    7E             C               LD      A,(HL)                ;and save first byte of fcb also
  F26C    32 F3E0        C               LD      (AUTOFLAG),A          ;this must be non-zero
  F26F    E6 E0          C               AND     0E0H                  ;whats this for (bits 6,7 are used for
  F271    77             C               LD      (HL),A                ;something)?
  F272    CD F245        C               CALL    SETDSK                ;select and log in this drive
  F275                   C      AUTOSL1:
  F275    3A E941        C               LD      A,(USERNO)            ;move user number into fcb
  F278    2A E943        C               LD      HL,(PARAMS)           ;(* upper half of first byte *)
  F27B    B6             C               OR      (HL)
  F27C    77             C               LD      (HL),A
  F27D    C9             C               RET                           ;and return (all done)
                         C      
                         C      ;
''      MACRO-80 3.44   09-Dec-81       PAGE    1-42


                         C      ;   Function to return the current cp/m version number
                         C      ;
  F27E                   C      GETVER:
  F27E    3E 22          C               LD      A,022H                ;version 2.2
  F280    C3 E901        C               JP      SETSTAT
                         C      
                         C      ;
                         C      ;   Function to reset the disk system
                         C      ;
  F283                   C      RSTDSK:
  F283    21 0000        C               LD      HL,0                  ;clear write protect status and log
  F286    22 F3AD        C               LD      (WRTPRT),HL           ;in vector
  F289    22 F3AF        C               LD      (LOGIN),HL
  F28C    AF             C               XOR     A                     ;select drive 'A'
  F28D    32 E942        C               LD      (ACTIVE),A
  F290    21 0080        C               LD      HL,TBUFF              ;setup default dma address
  F293    22 F3B1        C               LD      (USERDMA),HL
  F296    CD EBDA        C               CALL    DEFDMA
  F299    C3 F221        C               JP      LOGINDRV              ;now log in drive 'A'
                         C      
                         C      ;
                         C      ;   Function to open a specified file
                         C      ;
  F29C                   C      OPENFIL:
  F29C    CD EB72        C               CALL    CLEARS2               ;clear 's2' byte
  F29F    CD F251        C               CALL    AUTOSEL               ;select proper disk
  F2A2    C3 EE51        C               JP      OPENIT                ;and open the file
                         C      
                         C      ;
                         C      ;   Function to close a specified file
                         C      ;
  F2A5                   C      CLOSEFIL:
  F2A5    CD F251        C               CALL    AUTOSEL               ;select proper disk
  F2A8    C3 EEA2        C               JP      CLOSEIT               ;and close the file
                         C      
                         C      ;
                         C      ;   Function to return the first occurence of a specified file name
                         C      ;   If the first byte of the fcb is '?' then the name will not be checked (get the first entry no matter what)
                         C      ;
  F2AB                   C      GETFST:
  F2AB    0E 00          C               LD      C,0                   ;prepare for special search
  F2AD    EB             C               EX      DE,HL
  F2AE    7E             C               LD      A,(HL)                ;is first byte a '?'?
  F2AF    FE 3F          C               CP      '?'
  F2B1    CA F2C2        C               JP      Z,GETFST1             ;yes, just get very first entry (zero length match)
  F2B4    CD EAA6        C               CALL    SETEXT                ;get the extension byte from fcb
  F2B7    7E             C               LD      A,(HL)                ;is it '?'? if yes, then we want
  F2B8    FE 3F          C               CP      '?'                   ;an entry with a specific 's2' byte
  F2BA    C4 EB72        C               CALL    NZ,CLEARS2            ;otherwise, look for a zero 's2' byte
  F2BD    CD F251        C               CALL    AUTOSEL               ;select proper drive
  F2C0    0E 0F          C               LD      C,15                  ;compare bytes 0-14 in fcb (12&13 excluded)
  F2C2                   C      GETFST1:
  F2C2    CD ED18        C               CALL    FINDFST               ;find an entry and then move it into
  F2C5    C3 EBE9        C               JP      MOVEDIR               ;the users dma space
                         C      
                         C      ;
                         C      ;   Function to return the next occurence of a file name
                         C      ;
  F2C8                   C      GETNXT:
  F2C8    2A F3D9        C               LD      HL,(SAVEFCB)          ;restore pointers. note that no
  F2CB    22 E943        C               LD      (PARAMS),HL           ;other dbos calls are allowed
  F2CE    CD F251        C               CALL    AUTOSEL               ;no error will be returned, but the
  F2D1    CD ED2D        C               CALL    FINDNXT               ;results will be wrong
  F2D4    C3 EBE9        C               JP      MOVEDIR
                         C      
                         C      ;
                         C      ;   Function to delete a file by name
                         C      ;
  F2D7                   C      DELFILE:
  F2D7    CD F251        C               CALL    AUTOSEL               ;select proper drive
  F2DA    CD ED9C        C               CALL    ERAFILE               ;erase the file
  F2DD    C3 ED01        C               JP      STSTATUS              ;set status and return
                         C      
                         C      ;
                         C      ;   Function to execute a sequential read of the specified record number
                         C      ;
  F2E0                   C      READSEQ:
  F2E0    CD F251        C               CALL    AUTOSEL               ;select proper drive then read
  F2E3    C3 EFBC        C               JP      RDSEQ
                         C      
                         C      ;
                         C      ;   Function to write the net sequential record
                         C      ;
''      MACRO-80 3.44   09-Dec-81       PAGE    1-43


  F2E6                   C      WRTSEQ:
  F2E6    CD F251        C               CALL    AUTOSEL               ;select proper drive then write
  F2E9    C3 EFFE        C               JP      WTSEQ
                         C      
                         C      ;
                         C      ;   Create a file function
                         C      ;
  F2EC                   C      FCREATE:
  F2EC    CD EB72        C               CALL    CLEARS2               ;clear the 's2' byte on all creates
  F2EF    CD F251        C               CALL    AUTOSEL               ;select proper drive and get the next
  F2F2    C3 EF24        C               JP      GETEMPTY              ;empty directory space
                         C      
                         C      ;
                         C      ;   Function to rename a file
                         C      ;
  F2F5                   C      RENFILE:
  F2F5    CD F251        C               CALL    AUTOSEL               ;select proper drive and then switch
  F2F8    CD EE16        C               CALL    CHGNAMES              ;file names
  F2FB    C3 ED01        C               JP      STSTATUS
                         C      
                         C      ;
                         C      ;   Function to return the login vector
                         C      ;
  F2FE                   C      GETLOG:
  F2FE    2A F3AF        C               LD      HL,(LOGIN)
  F301    C3 F329        C               JP      GETPRM1
                         C      
                         C      ;
                         C      ;   Function to return the current disk assignment
                         C      ;
  F304                   C      GETCRNT:
  F304    3A E942        C               LD      A,(ACTIVE)
  F307    C3 E901        C               JP      SETSTAT
                         C      
                         C      ;
                         C      ;   Function to set the dma address
                         C      ;
  F30A                   C      PUTDMA:
  F30A    EB             C               EX      DE,HL
  F30B    22 F3B1        C               LD      (USERDMA),HL          ;save in our space and then get to
  F30E    C3 EBDA        C               JP      DEFDMA                ;the bios with this also
                         C      
                         C      ;
                         C      ;   Function to return the allocation vector
                         C      ;
  F311                   C      GETALOC:
  F311    2A F3BF        C               LD      HL,(ALOCVECT)
  F314    C3 F329        C               JP      GETPRM1
                         C      
                         C      ;
                         C      ;   Function to return the read-only status vector
                         C      ;
  F317                   C      GETROV:
  F317    2A F3AD        C               LD      HL,(WRTPRT)
  F31A    C3 F329        C               JP      GETPRM1
                         C      
                         C      ;
                         C      ;   Function to set the file attributes (read-only, system)
                         C      ;
  F31D                   C      SETATTR:
  F31D    CD F251        C               CALL    AUTOSEL               ;select proper drive then save attributes
  F320    CD EE3B        C               CALL    SAVEATTR
  F323    C3 ED01        C               JP      STSTATUS
                         C      
                         C      ;
                         C      ;   Function to return the address of the disk parameter block for the current drive.
                         C      ;
  F326                   C      GETPARM:
  F326    2A F3BB        C               LD      HL,(DISKPB)
  F329                   C      GETPRM1:
  F329    22 E945        C               LD      (STATUS),HL
  F32C    C9             C               RET
                         C      
                         C      ;
                         C      ;   Function to get or set the user number
                         C      ;   If (E) was (FF) then this is a request to return the current user number
                         C      ;   Else set the user number from (E)
                         C      ;
  F32D                   C      GETUSER:
  F32D    3A F3D6        C               LD      A,(EPARAM)            ;get parameter
  F330    FE FF          C               CP      0FFH                  ;get user number?
  F332    C2 F33B        C               JP      NZ,SETUSER
  F335    3A E941        C               LD      A,(USERNO)            ;yes, just do it
''      MACRO-80 3.44   09-Dec-81       PAGE    1-44


  F338    C3 E901        C               JP      SETSTAT
                         C      
  F33B                   C      SETUSER:
  F33B    E6 1F          C               AND     01FH                  ;no, we should set it instead. keep low
  F33D    32 E941        C               LD      (USERNO),A            ;bits (0-4) only
  F340    C9             C               RET
                         C      
                         C      ;
                         C      ;   Function to read a random record from a file
                         C      ;
  F341                   C      RDRANDOM:
  F341    CD F251        C               CALL    AUTOSEL               ;select proper drive and read
  F344    C3 F193        C               JP      READRAN
                         C      
                         C      ;
                         C      ;   Function to compute the file size for random files
                         C      ;
  F347                   C      WTRANDOM:
  F347    CD F251        C               CALL    AUTOSEL               ;select proper drive and write
  F34A    C3 F19C        C               JP      WRITERAN
                         C      
                         C      ;
                         C      ;   Function to compute the size of a random file
                         C      ;
  F34D                   C      FILESIZE:
  F34D    CD F251        C               CALL    AUTOSEL               ;select proper drive and check file length
  F350    C3 F1D2        C               JP      RANSIZE
                         C      
                         C      ;
                         C      ;   Function #37
                         C      ;   This allows a program to log off any drives
                         C      ;   On entry, set (DE) to contain a word with bits set for those drives that are to be logged off
                         C      ;   The log-in vector and the write protect vector will be updated. This must be a M/PM special function
                         C      ;
  F353                   C      LOGOFF:
  F353    2A E943        C               LD      HL,(PARAMS)           ;get drives to log off
  F356    7D             C               LD      A,L                   ;for each bit that is set, we want
  F357    2F             C               CPL                           ;to clear that bit in (LOGIN)
  F358    5F             C               LD      E,A                   ;and (WRTPRT)
  F359    7C             C               LD      A,H
  F35A    2F             C               CPL
  F35B    2A F3AF        C               LD      HL,(LOGIN)            ;reset the login vector
  F35E    A4             C               AND     H
  F35F    57             C               LD      D,A
  F360    7D             C               LD      A,L
  F361    A3             C               AND     E
  F362    5F             C               LD      E,A
  F363    2A F3AD        C               LD      HL,(WRTPRT)
  F366    EB             C               EX      DE,HL
  F367    22 F3AF        C               LD      (LOGIN),HL            ;and save
  F36A    7D             C               LD      A,L                   ;now do the write protect vector
  F36B    A3             C               AND     E
  F36C    6F             C               LD      L,A
  F36D    7C             C               LD      A,H
  F36E    A2             C               AND     D
  F36F    67             C               LD      H,A
  F370    22 F3AD        C               LD      (WRTPRT),HL           ;and save. all done
  F373    C9             C               RET
                         C      
                         C      ;
                         C      ;   Get here to return to the user.
                         C      ;
  F374                   C      GOBACK:
  F374    3A F3DE        C               LD      A,(AUTO)              ;was auto select activated?
  F377    B7             C               OR      A
  F378    CA F391        C               JP      Z,GOBACK1
  F37B    2A E943        C               LD      HL,(PARAMS)           ;yes, but was a change made?
  F37E    36 00          C               LD      (HL),0                ;(* reset first byte of fcb *)
  F380    3A F3E0        C               LD      A,(AUTOFLAG)
  F383    B7             C               OR      A
  F384    CA F391        C               JP      Z,GOBACK1
  F387    77             C               LD      (HL),A                ;yes, reset first byte properly
  F388    3A F3DF        C               LD      A,(OLDDRV)            ;and get the old drive and select it
  F38B    32 F3D6        C               LD      (EPARAM),A
  F38E    CD F245        C               CALL    SETDSK
  F391                   C      GOBACK1:
  F391    2A E90F        C               LD      HL,(USRSTACK)         ;reset the users stack pointer
  F394    F9             C               LD      SP,HL
  F395    2A E945        C               LD      HL,(STATUS)           ;get return status
  F398    7D             C               LD      A,L                   ;force version 1.4 compatability
  F399    44             C               LD      B,H
  F39A    C9             C               RET                           ;and go back to user
                         C      
''      MACRO-80 3.44   09-Dec-81       PAGE    1-45


                         C      ;
                         C      ;   Function #40
                         C      ;   This is a special entry to do random i/o
                         C      ;   For the case where we are writing to unused disk space, this space will be zeroed out first
                         C      ;   This must be a M/PM special purpose function, because why would any normal program even
                         C      ;     care about the previous contents of a sector about to be written over
                         C      ;
  F39B                   C      WTSPECL:
  F39B    CD F251        C               CALL    AUTOSEL               ;select proper drive
  F39E    3E 02          C               LD      A,2                   ;use special write mode
  F3A0    32 F3D5        C               LD      (MODE),A
  F3A3    0E 00          C               LD      C,0                   ;set write indicator
  F3A5    CD F107        C               CALL    POSITN1               ;position the file
  F3A8    CC F003        C               CALL    Z,WTSEQ1              ;and write (if no errors)
  F3AB    C9             C               RET
                         C      
                         C               PAGE
''      MACRO-80 3.44   09-Dec-81       PAGE    1-46


                         C      
                         C      ;
                         C      ;**************************************************************
                         C      ;*     BDOS data storage pool
                         C      ;**************************************************************
                         C      ;
  F3AC    E5             C      EMPTYFCB:DEFB    0E5H                  ;empty directory segment indicator
  F3AD    0000           C      WRTPRT:  DEFW    0                     ;write protect status for all 16 drives
  F3AF    0000           C      LOGIN:   DEFW    0                     ;drive active word (1 bit per drive)
  F3B1    0080           C      USERDMA: DEFW    TBUFF                 ;user's dma address (defaults to 80h)
                         C      ;
                         C      ;   Scratch areas from parameter block
                         C      ;
  F3B3    0000           C      SCRATCH1:DEFW    0                     ;relative position within dir segment for file (0-3)
  F3B5    0000           C      SCRATCH2:DEFW    0                     ;last selected track number
  F3B7    0000           C      SCRATCH3:DEFW    0                     ;last selected sector number
                         C      ;
                         C      ;   Disk storage areas from parameter block
                         C      ;
  F3B9    0000           C      DIRBUF:  DEFW    0                     ;address of directory buffer to use
  F3BB    0000           C      DISKPB:  DEFW    0                     ;contains address of disk parameter block
  F3BD    0000           C      CHKVECT: DEFW    0                     ;address of check vector
  F3BF    0000           C      ALOCVECT:DEFW    0                     ;address of allocation vector (bit map)
                         C      ;
                         C      ;   Parameter block returned from the bios
                         C      ;
  F3C1    0000           C      SECTORS: DEFW    0                     ;sectors per track from bios
  F3C3    00             C      BLKSHFT: DEFB    0                     ;block shift
  F3C4    00             C      BLKMASK: DEFB    0                     ;block mask
  F3C5    00             C      EXTMASK: DEFB    0                     ;extent mask
  F3C6    0000           C      DSKSIZE: DEFW    0                     ;disk size from bios (number of blocks-1)
  F3C8    0000           C      DIRSIZE: DEFW    0                     ;directory size
  F3CA    0000           C      ALLOC0:  DEFW    0                     ;storage for first bytes of bit map (dir space used)
  F3CC    0000           C      ALLOC1:  DEFW    0
  F3CE    0000           C      OFFSET:  DEFW    0                     ;first usable track number
  F3D0    0000           C      XLATE:   DEFW    0                     ;sector translation table address
                         C      ;
                         C      ;
  F3D2    00             C      CLOSEFLG:DEFB    0                     ;close flag (=0ffh is extent written ok)
  F3D3    00             C      RDWRTFLG:DEFB    0                     ;read/write flag (0ffh=read, 0=write)
  F3D4    00             C      FNDSTAT: DEFB    0                     ;filename found status (0=found first entry)
  F3D5    00             C      MODE:    DEFB    0                     ;I/o mode select (0=random, 1=sequential, 2=special random)
  F3D6    00             C      EPARAM:  DEFB    0                     ;storage for register (E) on entry to bdos
  F3D7    00             C      RELBLOCK:DEFB    0                     ;relative position within fcb of block number written
  F3D8    00             C      COUNTER: DEFB    0                     ;byte counter for directory name searches
  F3D9    0000 0000      C      SAVEFCB: DEFW    0,0                   ;save space for address of fcb (for directory searches)
  F3DD    00             C      BIGDISK: DEFB    0                     ;if =0 then disk is > 256 blocks long
  F3DE    00             C      AUTO:    DEFB    0                     ;if non-zero, then auto select activated
  F3DF    00             C      OLDDRV:  DEFB    0                     ;on auto select, storage for previous drive
  F3E0    00             C      AUTOFLAG:DEFB    0                     ;if non-zero, then auto select changed drives
  F3E1    00             C      SAVNXT:  DEFB    0                     ;storage for next record number to access
  F3E2    00             C      SAVEXT:  DEFB    0                     ;storage for extent number of file
  F3E3    0000           C      SAVNREC: DEFW    0                     ;storage for number of records in file
  F3E5    0000           C      BLKNMBR: DEFW    0                     ;block number (physical sector) used within a file or logical sect
  F3E7    0000           C      LOGSECT: DEFW    0                     ;starting logical (128 byte) sector of block (physical sector)
  F3E9    00             C      FCBPOS:  DEFB    0                     ;relative position within buffer for fcb of file of interest
  F3EA    0000           C      FILEPOS: DEFW    0                     ;files position within directory (0 to max entries -1)
                         C      ;
                         C      ;   Disk directory buffer checksum bytes
                         C      ;   One for each of the 16 possible drives
                         C      ;
  F3EC    00 00 00 00    C      CKSUMTBL:DEFB    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  F3F0    00 00 00 00    C      
  F3F4    00 00 00 00    C      
  F3F8    00 00 00 00    C      
                         C      ;
                         C      ;   Extra space ?
                         C      ;
  F3FC    00 00 00 00    C               DEFB    0,0,0,0
                         C      
                         C              PAGE
''      MACRO-80 3.44   09-Dec-81       PAGE    1-47


                         C      
                         C      ;
                         C      ;**************************************************************
                         C      ;*        B I O S   J U M P   T A B L E
                         C      ;**************************************************************
                         C      ;
  F400                   C      BOOT     EQU     $                     ;NOTE WE USE FAKE DESTINATIONS
  F403                   C      WBOOT    EQU     BOOT + 3
  F406                   C      CONST    EQU     WBOOT + 3
  F409                   C      CONIN    EQU     CONST + 3
  F40C                   C      CONOUT   EQU     CONIN + 3
  F40F                   C      LIST     EQU     CONOUT + 3
  F412                   C      PUNCH    EQU     LIST + 3
  F415                   C      READER   EQU     PUNCH + 3
  F418                   C      HOME     EQU     READER + 3
  F41B                   C      SELDSK   EQU     HOME + 3
  F41E                   C      SETTRK   EQU     SELDSK + 3
  F421                   C      SETSEC   EQU     SETTRK + 3
  F424                   C      SETDMA   EQU     SETSEC + 3
  F427                   C      READ     EQU     SETDMA + 3
  F42A                   C      WRITE    EQU     READ + 3
  F42D                   C      PRSTAT   EQU     WRITE + 3
  F430                   C      SECTRN   EQU     PRSTAT + 3
                         C      
  F400                   C      BDOSEND  EQU     $
                         C      
                         C              .DEPHASE
                         C      ;
                         C      ;*
                         C      ;******************   E N D   O F   C P / M   *****************
                         C      ;*
                         C      
                         C      ;       END
                                
                                        TITLE ''
                                        END
''      MACRO-80 3.44   09-Dec-81       PAGE    S


Macros:

Symbols:
E942    ACTIVE          EB64    ADDA2HL         F3CA    ALLOC0          
F3CC    ALLOC1          F3BF    ALOCVECT        F3DE    AUTO            
F3E0    AUTOFLAG        F251    AUTOSEL         F275    AUTOSL1         
E7A4    BACKUP          E7AC    BACKUP1         E609    BADSCTR         
E6CA    BADSEC          E6D5    BADSEL          E60B    BADSLCT         
E600    BDOS            E6C6    BDOSDRV         F400    BDOSEND         
E6BA    BDOSERR         0007    BELL            F3DD    BIGDISK         
ECA3    BITMAP          ECB1    BITMAP1         ECD2    BITMAP2         
ECF6    BITMAP3         0020    BLANK           F3C4    BLKMASK         
F3E5    BLKNMBR         F3C3    BLKSHFT         F400    BOOT            
0008    BS              E90E    CHARBUF         EB9E    CHECKDIR        
EAF7    CHECKSUM        EE27    CHGNAM1         EE16    CHGNAMES        
EA84    CHKBLK          E714    CHKCHAR         EBC4    CHKDIR1         
EB8C    CHKNMBR         EB44    CHKROFL         EAFD    CHKSUM1         
F3BD    CHKVECT         EB54    CHKWPRT         EC35    CKBITMAP        
EC56    CKBMAP1         E742    CKCON1          E745    CKCON2          
E723    CKCONSOL        EBF5    CKFILPOS        EB47    CKROF1          
F3EC    CKSUMTBL        EB72    CLEARS2         F2A5    CLOSEFIL        
F3D2    CLOSEFLG        EEA2    CLOSEIT         EECD    CLOSEIT1        
EEDB    CLOSEIT2        EEE1    CLOSEIT3        EEE8    CLOSEIT4        
EEFD    CLOSEIT5        EF17    CLOSEIT6        EF1F    CLOSEIT7        
EA77    COMBLK          F1A5    COMPRAND        F409    CONIN           
F40C    CONOUT          F406    CONST           F3D8    COUNTER         
000D    CR              0003    CTRLC           0005    CTRLE           
0010    CTRLP           0012    CTRLR           0013    CTRLS           
0015    CTRLU           0018    CTRLX           001A    CTRLZ           
E90C    CURPOS          E94F    DE2HL           E950    DE2HL1          
EBDA    DEFDMA          007F    DEL             F2D7    DELFILE         
F3B9    DIRBUF          E8E0    DIRC1           E8D4    DIRCIO          
EBE0    DIRDMA          EBE3    DIRDMA1         EBD4    DIRREAD         
F3C8    DIRSIZE         EBC6    DIRWRITE        F3BB    DISKPB          
E6E1    DISKRO          E9B2    DOREAD          E9B8    DOWRITE         
F3C6    DSKSIZE         F3AC    EMPTYFCB        F3D6    EPARAM          
EDA4    ERAFIL1         ED9C    ERAFILE         E699    ERROR1          
E6A5    ERROR2          E6AB    ERROR3          E6B1    ERROR4          
E6B4    ERROR5          EA5E    EXTBLK          EA71    EXTBLK1         
F3C5    EXTMASK         E606    FBASE           E611    FBASE1          
EB5E    FCB2HL          F3E9    FCBPOS          EDFD    FCBSET          
F2EC    FCREATE         000F    FF              F3EA    FILEPOS         
E6DC    FILERO          F34D    FILESIZE        ED18    FINDFST         
ED2D    FINDNXT         ED4A    FNDNXT1         ED53    FNDNXT2         
ED73    FNDNXT3         ED7C    FNDNXT4         ED83    FNDNXT5         
ED94    FNDNXT6         EDC0    FNDSPA1         EDD1    FNDSPA2         
EDEC    FNDSPA3         EDF4    FNDSPA4         EDBE    FNDSPACE        
F3D4    FNDSTAT         E647    FUNCTNS         F311    GETALOC         
EA45    GETBLK1         EA53    GETBLK2         EA5C    GETBLK3         
EA3E    GETBLOCK        E6FB    GETCHAR         E8C8    GETCON          
F304    GETCRNT         E8FE    GETCSTS         E706    GETECHO         
EF24    GETEMPTY        F2AB    GETFST          F2C2    GETFST1         
E8ED    GETIOB          F2FE    GETLOG          EF46    GETMT1          
EF5A    GETNEXT         F2C8    GETNXT          F326    GETPARM         
F329    GETPRM1         E8CE    GETRDR          F317    GETROV          
EB69    GETS2           F32D    GETUSER         F27E    GETVER          
EB1E    GETWPRT         F374    GOBACK          F391    GOBACK1         
EF83    GTNEXT1         EF8E    GTNEXT2         EFAC    GTNEXT3         
EFAF    GTNEXT4         EFB6    GTNEXT5         F418    HOME            
E9A1    HOMEDRV         0003    IOBYTE          E905    IOERR1          
E9BB    IORET           E94A    JUMPHL          000A    LF              
F40F    LIST            EA8A    LOGICAL         EA90    LOGICL1         
F3AF    LOGIN           F221    LOGINDRV        F353    LOGOFF          
F3E7    LOGSECT         F3D5    MODE            EB7F    MOREFLS         
EBE9    MOVEDIR         EE94    MOVEWORD        E7B1    NEWLINE         
E7B9    NEWLN1          0029    NFUNCTS         EC19    NXENT1          
EC20    NXENT2          EC05    NXENTRY         F3CE    OFFSET          
F3DF    OLDDRV          F29C    OPENFIL         EE51    OPENIT          
EE5A    OPENIT1         EE8B    OPENIT2         E748    OUTCHAR         
E762    OUTCHR1         E779    OUTCHR2         E790    OUTCON          
E796    OUTCON1         E7C9    OUTCRLF         E90A    OUTFLAG         
E943    PARAMS          F103    POSITION        F107    POSITN1         
F147    POSITN2         F17F    POSITN3         F184    POSITN4         
F18B    POSITN5         003E    PROMPT          F42D    PRSTAT          
E6E5    PRTERR          E90D    PRTFLAG         E7D3    PRTMESG         
E8F8    PRTSTR          F412    PUNCH           F30A    PUTDMA          
F1E4    RANSIZ1         F206    RANSIZ2         F20C    RANSIZ3         
F1D2    RANSIZE         E7EF    RDBUF1          E870    RDBUF10         
E878    RDBUF11         E88A    RDBUF12         E899    RDBUF13         
E8A6    RDBUF14         E8A9    RDBUF15         E8BD    RDBUF16         
E8C1    RDBUF17         E7F1    RDBUF2          E816    RDBUF3          
E826    RDBUF4          E837    RDBUF5          E848    RDBUF6          
''      MACRO-80 3.44   09-Dec-81       PAGE    S-1


E84E    RDBUF7          E85F    RDBUF8          E86B    RDBUF9          
E7E1    RDBUFF          F341    RDRANDOM        EFBC    RDSEQ           
EFC1    RDSEQ1          EFE6    RDSEQ2          EFFB    RDSEQ3          
F3D3    RDWRTFLG        F427    READ            F415    READER          
F193    READRAN         F2E0    READSEQ         F3D7    RELBLOCK        
F2F5    RENFILE         E60D    RODISK          E60F    ROFILE          
F283    RSTDSK          E904    RTN             ED07    SAMEXT          
EE40    SAVATR1         EE3B    SAVEATTR        F3D9    SAVEFCB         
F3E2    SAVEXT          F3E3    SAVNREC         F3E1    SAVNXT          
F3B3    SCRATCH1        F3B5    SCRATCH2        F3B7    SCRATCH3        
F3C1    SECTORS         F430    SECTRN          F41B    SELDSK          
E959    SELECT          E99D    SELECT1         F31D    SETATTR         
EB0B    SETBIT          EB9C    SETDIR          F424    SETDMA          
F245    SETDSK          EAA6    SETEXT          EC6B    SETFILE         
EC75    SETFL1          EC88    SETFL2          EC8E    SETFL3          
EC9D    SETFL4          EAAE    SETHLDE         E8F3    SETIOB          
EAD2    SETNREC         F20E    SETRAN          EB78    SETS2B7         
F421    SETSEC          E901    SETSTAT         F41E    SETTRK          
F33B    SETUSER         EB04    SHIFTL          EB05    SHIFTL1         
EAEA    SHIFTR          EAEB    SHIFTR1         E77F    SHOWIT          
E947    SLCTERR         E90B    STARTING        E945    STATUS          
EC5C    STBITMAP        EC64    STBMAP1         EBFE    STFILPOS        
E941    STKAREA         EADE    STNREC1         EABB    STRDATA         
ED01    STSTATUS        EB95    SUBHL           0009    TAB             
0080    TBUFF           E9C3    TRKSEC          E9D1    TRKSEC1         
E9E4    TRKSEC2         E9FA    TRKSEC3         EA0F    TRKSEC4         
EE01    UPDATE          EE10    UPDATE1         F3B1    USERDMA         
E941    USERNO          E90F    USRSTACK        F403    WBOOT           
F42A    WRITE           F19C    WRITERAN        F3AD    WRTPRT          
EB2C    WRTPRTD         F2E6    WRTSEQ          F347    WTRANDOM        
EFFE    WTSEQ           F003    WTSEQ1          F0D2    WTSEQ10         
F0FE    WTSEQ11         F100    WTSEQ12         F03B    WTSEQ2          
F048    WTSEQ3          F064    WTSEQ4          F06C    WTSEQ5          
F06E    WTSEQ6          F08C    WTSEQ7          F09A    WTSEQ8          
F0BB    WTSEQ9          F0DF    WTSEQ99         F39B    WTSPECL         
F3D0    XLATE           



No Fatal error(s)

