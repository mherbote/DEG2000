
.Z80

TITLE 'MONITOR  821128 3.3'
PAGE 60

;**********************************
;* RDK MONITOR  1.0  800702       *
;* VERSION PIO,MINI,MAXI      	  *
;* REV 3.2 830205  ready direct   *
;* rev 3.3 830318  spez umsch     *
;* rev 3.4 830408  dcd cts rts    *
;*                 fuer term1     *
;* 6.87 3.4HE f}r Eprom-Floppy    *
;**********************************

;CSEG
;
; IM ROM AUF ADRESSE 0
;
BEGINN:
LD SP,0FFFFH	;DUMMY LOAD 
LD A,0C9H	;ABLAGE RET BEFEHL
LD (0F000H),A	;AUF ZIELADRESSE
CALL 0F000H	;FESTSTELLEN
ANF:		;DER EIGENEN ADRESSE
DEC SP		;UM START VON BELIEBIGER
DEC SP		;STELLE AUS ZU ERMOEGLICHEN
POP DE		;FUER TESTS SEHR GUT
LD HL,HAUPTP-ANF
ADD HL,DE
LD DE,0F000H	;TRANSPORT ALLER ZELLEN
LD BC,0FFFH	;4K TRANSFER
LDIR		;EIGENTLICH ZUVIEL ABER
JP 0F000H	;STOERT NICHT WEITER
;
HAUPTP:		;DISTANZ MERKER
;
.PHASE 0F000H	;START DES MONITORS
		;CODE DENOCH HINTER BOOT BEREICH

; --- START DES EIGENTLICHEN MONITORS ---
;
CR	EQU	0DH
LF	EQU	0AH
BELL	EQU	7
RUB	EQU	0FFH
FIL	EQU	0
MAX	EQU	7

RST7	EQU	38H
; ANFANG VERSCHIEBBAR
; der Vektor RST7 wird fuer Breakpoints gebraucht
;

;
SIOADAT	EQU	0F0H
SIOASTS	EQU	0F1H
SIOBDAT	EQU	0F2H
SIOBSTS	EQU	0F3H
;



;* VEKTOR TABELLE *
; CSTS 0FFH IN A FALLS ZEICHEN DA
; IOCHK IN A AKTUELLE IO KONFIGURATION
; IOSET VERAENDERN IO IN C REG
; MEMCK IN B HIGH IN A LOW MEMORY
; TRAP BREAKPOINT ENTRY


; START DES MONITORPROGRAMMS
JP BEGIN
JP CI
JP RI
JP CO
JP POO
JP LO
JP CSTS
JP IOBYTE
JP IOSET
JP MEMCK
TRAP:
JP RESTART1
JP RESTART1	;-FLOPPY EXEC VEKTOR HARD
JP MAXI		;FLOPPY EXEC VEKTOR SOFT
JP MINI		;FLOPPY EXEC VEKTOR MINI
JP RESTART1	;-IMISYS PLATTE EXEC VECTOR
;
; 
;
DEFW TABSTART	;TABELLEN START USER BEREICH
		;SPRUNGTABELLE , IMMER
		;INDIREKT VERWENDEN
DEFW LASTMON	;ADRESSE LETZTE BELEGTE ZELLE
		;DES MONITORS DANACH PATCH FREI
DEFW FREEMEM	;ueberladeadresse hinter IO-Gebiet
;
RESTART1:
JP RESTART	;kann kurzgeschlossen werden
		;nach freemem ueberschreibung

BEGIN:
JP BEGIN1	;kurzschliessen ggf.
;
; ende fixed gebiet

;
;**************************************
;* IO Routinen                        *
;**************************************

;+++ CI MAIN ROUTINE +++
CI:
LD A,(IOBYT)
AND 3	;CONSOLMASKE
JR NZ,CI1	;ANDERE DEVICE
TTYIN:
IN A,(SIOASTS)
AND 1
JR Z,TTYIN
IN A,(SIOADAT)
RET

CI1:
JP USERCI 	;DORT SPRUNG MOEGLICH


;+++ RI ROUTINE +++

RI:
LD A,(IOBYT)
AND 00001100B
JP Z,CI		;AR=T
CP 00000100B	
JP NZ,USERRI
LXLPI:		;AR=P
IN A,(SIOBSTS)
AND 1
JR Z,LXLPI
IN A,(SIOBDAT)
RET
;

; +++ MAIN CO ROUTINE +++ MOD
;
CO:
LD A,(IOBYT)
AND 3
JR NZ,CO1
;
TTYOUT:
IN A,(SIOASTS)
AND 4
JR Z,TTYOUT
LD A,C
OUT (SIOADAT),A
RET
;
CO1:
JP USERCO	;DORT SPRUNG MOEGLICH
;
;
;
POO:	;+++ MAIN POO ROUTINE +++
	;HIER ABFRAGE IOBYT MOEGLICH
LD A,(IOBYT)
AND 00110000B
JP Z,CO		;AP=T
CP 00010000B
JP NZ,USERPOO
LXLPO:		;AP=P
IN A,(SIOBSTS)
AND 4
JR Z,LXLPO
LD A,C
OUT (SIOBDAT),A
RET
;
;
; +++ MAIN LO ROUTINE +++ MOD

LO: 
LD A,(IOBYT)
AND 0C0H
JP Z,TTYOUT	;AL=T
CP 10000000B	;
JP NZ,USERLO
		;AL=L
LO1:
IN A,(SIOBSTS)
AND 4
JR Z,LO1
LD A,C
OUT (SIOBDAT),A
RET

;
CSTS:	;+++ MAIN STATUS ROUTINE +++
LD A,(IOBYT)
AND 3
JR NZ,CS0
TTYCSTS:
IN A,(SIOASTS)
AND 1
RET Z
LD A,0FFH
OR A
RET
;
CS0:
JP USERCSTS	;USER BEREICH
;

; Das IOBYTE dient der Umschaltung von
; physikalischem nach logischem Geraet
; Es hat die gleiche Bedeutung
; wie im CP/M-Bios 
;
;IOBYTE

IOBYTE:
LD A,(IOBYT)
RET

; IOSET
; kann z.B. im Bios gesetzt werden

IOSET:
LD A,C
LD (IOBYT),A
RET

;
MEMCK:	;prueft den Speicherbereich und gibt
	;die hoechste verfuegbare Zelle an
PUSH HL
CALL MEMSIZ
LD A,L
SUB 3CH
JR NC,LXBZ
DEC H
LXBZ:
LD B,H
POP HL
RET

;
;
MEMSIZ:	;Unterprogramm fuer Speicherendebestimmung
PUSH BC
LD HL,-1
LXM0:
INC H
LD A,(HL)
CPL
LD (HL),A
CP (HL)
CPL
LD (HL),A
JR NZ,LXM0
LXM1:
INC H
LD A,H
CP 0F0H		;ALL RAM
JR Z,LXM2	;READY 0F000H
LD A,(HL)	;max 0f000h da dort Monitor startet
CPL
LD (HL),A
CP (HL)
CPL
LD (HL),A
JR Z,LXM1
LXM2:
DEC H
LD BC,EXIT-ENDX
ADD HL,BC
POP BC
RET
;
TABSTART:		;TABELLE SPRUNG VEKTOREN
;
USERCI:		JP TTYIN
USERRI: 	JP TTYIN
USERCO: 	JP TTYOUT
USERPOO: 	JP TTYOUT
USERLO: 	JP TTYOUT
USERCSTS: 	JP TTYCSTS
;
IOBYT:	DEFB 80h	;IOBYTE SPEICHER  AL = L
OEXEC:	DEFS 3
IEXEC:	DEFS 3
KEXEC:	DEFS 3

;**********************************
;* FLOPPY INTERFACE PAKET         *
;* ROLF-DIETER KLEIN 820730       *
;* DRIVES  A    B		  *
;*          C    D                *
;* rev 821127 fehler dop stg      *
;* MINIMAX   kombinierte Routinen *
;* fuer den Betrieb von Mini und  *
;* Maxilaufwerken                 *
;* Es wird immer der gesamte      *
;* Sektor uebertragen             *
;* PIO nicht mehr noetig          *
;* rev 830318 select fehler doppel*
;* laufwerke                      *
;**********************************

;***** Maxi Floppy Eigenschaften *****
; MOTOR	
;*****                          ****** 
; WICHTIG :  DIE PORTS 30H..34H  UND 40H..44H
;            DUERFEN IM MC-COMPUTER NICHT MIT ANDEREN
;            BAUGRUPPEN BELEGT WERDEN, DA AUF BEIDE
;            SCHREIBEND ZUGEGRIFFEN WIRD AUCH WENN NUR
;            MINI ODER MAX-FLOPPY VERWENDET WERDEN

;
; HAUPTPROGRAMM EINSPRUNG
; DIE INTERRUPTROUTINE MUSS DURCH
; DEN MONITOR BEREITS IN DIE ENSTPRECHENDEN
; ZELLEN GESCHRIEBEN WORDEN SEIN
; DIES GESCHIEHT BEI EINEM CP/M BOOT
; DURCH DEN MONITOR

; Interruptroutine befindet sich nun mit im
; Monitor
INTEX:
POP AF
IN A,(40H)	;Maxi Floppy
EI
RET
;
INTEX1:
POP AF
IN A,(30H)	;Mini Floppy
EI
RET		
;
; Der Vektor wird dynamisch bei Anforderung an
; die Stelle 10H geladen um fuer alle CP/M
; Programme verwendbar zu sein
; 
INIFLP:
LD A,11b	;maxi steprate
LD (MAXSTP),A	;Voreinstellung
LD A,11b
LD (MINSTP),A	;mini steprate
RET
;

;
MINI:
LD A,0D0H	;TERMINATE IF BUSY
OUT (040H),A	;WICHTIG UM INTERRUPT ZU
OUT (030H),A	;VERHINDERN Z.B. BEI RESET
LD A,(10H)	;RETTEN SPRUNGSTELLE
LD (LOC10),A
LD A,0C3H
LD (10H),A
PUSH HL
LD HL,(11H)
LD (LOC10+1),HL
LD HL,INTEX1	;JP INTEX1 AUF 10H
LD (11H),HL
POP HL
IN A,(040H)
IN A,(030H)
EI
CALL MINISOFT	;MINIFLP
DI
PUSH AF
LD A,(LOC10)
LD (10H),A
PUSH HL
LD HL,(LOC10+1)
LD (11H),HL
POP HL
POP AF
RET
;


MAXI:
LD A,0D0H	;TERMINATE IF BUSY
OUT (040H),A	;
OUT (030H),A	
LD A,(10H)	;RETTEN SPRUNGSTELLE
LD (LOC10),A
LD A,0C3H
LD (10H),A
PUSH HL
LD HL,(11H)
LD (LOC10+1),HL
LD HL,INTEX	;JP INTEX AUF 10H
LD (11H),HL
POP HL
IN A,(040H)	;INT LOESCHEN FALLS NOCH DA
IN A,(030H)	;BEIDE FLOPPYS GGF.
EI
CALL MAXISOFT
DI
PUSH AF
LD A,(LOC10)
LD (10H),A
PUSH HL
LD HL,(LOC10+1)
LD (11H),HL
POP HL
POP AF
RET
;
;
SETUP:		;TESTET OB HEAD DOWN UND SETZT BIT
IN A,(44H)	;DIREKT BIT 5 ABFRAGE IST HEADLOAD
AND 20H		;=1 FALLS HEAD DOWN
JR NZ,MSKSK
LD A,4		;E=1 SETZEN
RET
MSKSK:
XOR A		;E=0
RET
;

MSETUP:		;TESTET OB HEAD DOWN UND SETZT BIT
IN A,(34H)	;DIREKT BIT 5 ABFRAGE IST HEADLOAD
AND 20H		;=1 FALLS HEAD DOWN
JR NZ,MSKSK
LD A,4		;E=1 SETZEN
RET
;



RDFLP:
LD A,E		;IN E SEKTOR
OUT (42H),A	;SEKTORSPEICHER
LD E,C		;IN C DRIVECODE + DENSITY
LD C,43H	;KANAL DATEN
CALL SETUP
ADD A,88H	;LESE BEF E=X
LD B,A
LD A,(MSIDE)	;CODE FUER DENSITY
OR B
OUT (40H),A	;CNTRL 1771 BEF
LD A,E
OUT (44H),A	;ENABLE NO AUTOWAIT BUT DENSE ETC
..LP8:		;LAENGE UNBESTIMMT BIS INT KOMMT
IN A,(44H)	;4MHZ WAIT ON READY
RLCA		;1=READY DRQ
JP NC,..LP8
INI
JP ..LP8

WRFLP:		;C AUF DRIVE 1...4 HL AUF BUFFER
LD A,E
OUT (42H),A	;IN E SEKTOR
LD E,C		;DRIVE CODE
LD C,43H	;LAENGE UNBESTIMMT BIS INT KOMMT
CALL SETUP	;E=X
ADD A,0A8H
LD B,A
LD A,(MSIDE)
OR B
		;SCHREIB BEF
OUT (40H),A
LD A,E
OUT (44H),A	;rev 821127
..LLP:
IN A,(44H)
RLCA
JP NC,..LLP
OUTI
JP ..LLP	;BIS INT KOMMT

WAWA:		;WARTESCHLEIFE
PUSH BC		;6YS.12YS/DURCHL
LD BC,500
..LP17:
DEC BC
LD A,B
OR C
JP NZ,..LP17
POP BC
RET		;


SEEK:		;C DRIVE 1...4 D TRK E SEKTOR
CALL WAWA	;!!!
LD A,C		;+ CODING AUSGEBEN
OUT (44H),A
LD A,E
OUT (42H),A	;SEKTOR
LD A,D
OUT (43H),A	;SUCHEN AUSFUEHREN AUF LOGIN DRIVE
LD B,1CH	;BEFEHL SEEK
LD A,(MAXSTP)
OR B		;step rate dynamisch
OUT (40H),A	;BEFKANAL
HALT
;

RSTORE:		;RESTORE IN CASE OF ERROR
CALL WAWA	;!!!
LD A,C		;DRIVE 1,2,4,8
AND 0FH
OUT (44H),A
LD B,0CH
LD A,(MAXSTP)
OR B
OUT (40H),A
HALT
;

MRDFLP:
LD A,E		;IN E SEKTOR
OUT (32H),A	;SEKTORSPEICHER
LD E,C		;IN C DRIVECODE + DENSITY
LD C,33H	;KANAL DATEN
CALL MSETUP
ADD A,88H	;LESE BEF E=X
LD B,A
LD A,(MSIDE)	;CODE FUER DENSITY
OR B
OUT (30H),A	;CNTRL 1771 BEF
LD A,E
OUT (34H),A	;ENABLE NO AUTOWAIT BUT DENSE ETC
..MLP8:		;LAENGE UNBESTIMMT BIS INT KOMMT
IN A,(34H)	;4MHZ WAIT ON READY
RLCA		;1=READY DRQ
JP NC,..MLP8
INI
JP ..MLP8

MWRFLP:		;C AUF DRIVE 1...4 HL AUF BUFFER
LD A,E
OUT (32H),A	;IN E SEKTOR
LD E,C		;DRIVE CODE
LD C,33H	;LAENGE UNBESTIMMT BIS INT KOMMT
CALL MSETUP	;E=X
ADD A,0A8H
LD B,A
LD A,(MSIDE)
OR B
		;SCHREIB BEF
OUT (30H),A
LD A,E
OUT (34H),A	;rev 821127
..MLLP:
IN A,(34H)
RLCA
JP NC,..MLLP
OUTI
JP ..MLLP	;BIS INT KOMMT
;

MSEEK:		;C DRIVE 1...4 D TRK E SEKTOR
CALL WAWA	;!!!
LD A,C		;+ CODING AUSGEBEN
OUT (34H),A
LD A,E
OUT (32H),A	;SEKTOR
LD A,D
OUT (33H),A	;SUCHEN AUSFUEHREN AUF LOGIN DRIVE
LD B,1CH	;BEFEHL SEEK
LD A,(MINSTP)
OR B		;step rate dynamisch
OUT (30H),A	;BEFKANAL
HALT
;

MRSTORE:	;RESTORE IN CASE OF ERROR
CALL WAWA	;!!!
LD A,C		;DRIVE 1,2,4,8
AND 0FH
OUT (34H),A
LD B,0CH
LD A,(MINSTP)
OR B
OUT (30H),A
HALT
;

;
MINISOFT:
SET 7,C
		; B=0 dann D=Steprate voreinst ist langsamste
		; D=0 high speed c=3 slowest rate
LD A,B		; C = drivecode wird ignoriert
OR A
JR NZ,XX1
; steprate einstellen
LD A,D
AND 03H
LD (MINSTP),A	;kein restore mehr ausf, sonst ggf hangup
XOR A
RET

;
MAXISOFT:
RES 7,C		;GEMEINSAMER CODE
		;B= COMMAND 0=RSTORE 1=READ 2=WRITE
		;C= DRIVE + Coding
		;HL POINTER AUF BUFFER
		;D=TRACK
		;E=SEKTOR
		; UMRECHNEN

		; B=0 dann D=Steprate voreinst ist langsamste
		; D=0 high speed c=3 slowest rate
LD A,B		; C = drivecode wird ignoriert
OR A
JR NZ,XX1
; steprate einstellen
LD A,D
AND 03H
LD (MAXSTP),A	;kein restore mehr ausf, sonst ggf hangup
XOR A
RET

;
XX1:

		;B=1 lesen B=2 schreiben
		;C=  0  1  2  3     0,2  1,3 gekoppelt
		;
		; =  10h,11h,12h,13h,14h,15h,16h,17h
		;    mit sideselekt (10h, 11h) jeweils gekoppelt
		;
		; =  20h,21h,22h,23h,24h,25h,26h,27h
		;    mit selekt 3 als side sel
		;    0,1,2 normal 20h,21h jeweils gekoppelt
		;Bit 7,6   codierung dense,mini,maxi
		;    1= minilaufwerk(auch bei maxieinsprg)
		;      1= double dense
XOR A
LD (FEHZA),A
LD (MSIDE),A	;side select = 0   std
LD A,C
		;minimax,densecode
AND 11000000b
RRCA
RRCA
LD (CCODE),A	;kombinierter drive dense code
		;codierung fuer drvcod,ccode bestimmen
		;ccode ist c register binaerform
		;drvcode 0..7  bit 0 ist seite des laufwerks
LD A,C
AND 00110000B	;=0 DANN FALL1
JR NZ,SKPV1
		;CODE 0,1,2,3    0,2   1,3 GEKOPPELT
LD A,C
AND 00000011B	;CODING
EXX
LD HL,TABM1
LD E,A
LD D,0
ADD HL,DE
ADD HL,DE
LD A,(HL)	;DRVCODE
LD (DRVCODE),A
INC HL
LD E,(HL)	
LD A,(CCODE)
OR E
LD (CCODE),A	;NEUER DRIVECODE
EXX
JR FISKP
TABM1:
DEFB 0,0001B
DEFB 2,0010B
DEFB 1,0100B
DEFB 3,1000B
;
SKPV1:
LD A,C
AND 00110000B	
CP  00010000B	;BEREICH 10H..17H
JR NZ,SKPV2
LD A,C
AND 00000111B	;0..7 BIT 0=SEL
LD (DRVCODE),A	;CODING
RRCA		;=CARRY DANN SIDE SEL=1
JR NC,SKPV12
LD A,00000010B	;SSO = 1 SETZEN
LD (MSIDE),A
SKPV12:
LD A,C
RRCA
AND 00000011B	;DRVCODE TABM1
EXX
LD HL,TABM1
LD E,A
LD D,0
ADD HL,DE
ADD HL,DE
INC HL
LD E,(HL)
LD A,(CCODE)
OR E
EXX
LD (CCODE),A	;CODIERUNG
JR FISKP
;
SKPV2:
LD A,C
AND 00000111B	;0..7 BIT 0=SEL
LD (DRVCODE),A	;CODING
RRCA		;=CARRY DANN SIDE SEL=1
JR NC,SKPV12
LD A,(CCODE)
OR 00001000B	;SELEKT SIDE
LD (CCODE),A
JR SKPV12
;
;

FISKP:		;DRVCODE,CCODE BESTIMMT  C REGISTER

LD A,C
BIT 7,A		;<>0 dann start
JP NZ,MINEXX	;minifloppy teil
LD A,(DRVCODE)
LD C,A		;code of drive 0..7  bit 0=side sel
;
LD A,(DRVAT)
CP C		;GLEICHE DRIVE
JP Z,..SK2	;WEITER DANN
 		; hier aber immer mit abb
		; end rev 821127
PUSH HL
PUSH BC
LD HL,DRVTAB	;TABELLEN INDEX BERECHNEN
LD A,(DRVAT)
CP 0FFH		;UNDEF
JR Z,NOD
RRCA		;
AND 00000011b
LD C,A
LD B,0
ADD HL,BC
IN A,(41H)	;ALTER TRACK
LD (HL),A	;RETTEN VOR RSTORE AUSFUEHRUNG NOETIG ABER
NOD:		;UNDEF
POP BC
POP HL		;ERSTMAL ALTE DRIVE RETTEN
PUSH HL
PUSH BC
LD HL,DRVTAB
LD A,C
RRCA		;
AND 00000011b
LD C,A
LD B,0		;IN C NEUE DRIVE
ADD HL,BC
LD A,(HL)
OUT (41H),A	;NEUER TRACK HOLEN
POP BC
POP HL
LD A,C
LD (DRVAT),A	;NUN NEUE DRIVE
PUSH AF		;NEU BUG 810917
PUSH BC		;BETREFF HEADLOAD
PUSH BC		;rev 821127
LD BC,1000*3/12	;1MS  BEI 6MHZ AUCH
..LPPD:
DEC BC
LD A,B
OR C
JP NZ,..LPPD	;WARTEN TUNNELERASE COMPLETED
POP BC		;rev 821127
LD A,(CCODE)	;rev 830318 vorher falsches reg
		;NEUE DRIVE CODED 1,2,4,8
AND 0FH		;AUSGEBEN
OUT (44H),A	;OHNE AUTOWAIT
;
LD BC,2917	;ca 35 MS WARTEN UNKRIT. (10MS..35MS)
..LP4:		;WICHTIG ABER BEI SCHREIBEN NACH LESEN
DEC BC		;FALLS DRIVES HEADLOAD BESITZEN
LD A,B
OR C
JP NZ,..LP4	;DA SONST SETTLE NICHT OK
POP BC
POP AF		;END 810917
		;rev 3.2
JR ..SKKK1	;bei laufwerkswechsel kann head load down
		;sein aber laufwerk nicht ready
		;daher immer dummy seek ausfuehren

..SK2:		;rev 3.2 ohne PIO
IN A,(44H)	;wenn head load vorliegt kann
AND 20H		;ready nicht ungueltig sein wegen reihenfolge
JR NZ,..OV	;fertig dann
	
..SKKK1:	;warte schleife seek solange bis status
		;ein ready angibt

LD A,(CCODE)
LD C,A		;drive code internal
CALL SELDUM	;SELEKT DUMMY AUSFUEHREN mit seek

IN A,(40H)	;bit 7 entscheidet
AND 80H
JR NZ,..SKKK1	;bis ausgefuehrt
		;drive wird nicht not ready ohne
		;das headload weggeht im normal fall
		;da nur MOTOR OFF automatik hier
		;wesentlich ist

..OV:
IN A,(41H)	;TRACK HOLEN
CP 0FFH		;AUS TRACKTABELLE
JR Z,..TRY1	;ERST RESTORE
CP D		;GLEICH DANN WEITER
JP Z,..SK11	;KEIN SUCHEN NOETIG
		;SUCHEN NOETIG
..TRY:
LD A,(CCODE)
LD C,A
PUSH HL
PUSH DE
PUSH BC
CALL SEEK
POP BC
POP DE
POP HL
AND 10010000B
JR Z,..SK11	;OK WEITER
..TRY1:		;EINGANG BEI LESEFEHLER UND SCHRBFEHLER
LD A,(CCODE)
LD C,A
		;FEHLER AUFGETRETEN
		;RSTORE AUSFUEHREN
PUSH HL
PUSH DE
PUSH BC
CALL RSTORE
POP BC
POP DE
POP HL
LD A,(FEHZA)	;FEHLER COUNT
INC A
LD (FEHZA),A
CP 10
JR C,..TRY
LD A,0FFH
OR A
SCF
RET		;FEHLER

;
..SK11:		;KEIN SEEK WAR NOETIG
LD A,B		;BEFEH
CP 2
JP Z,..WRTEX
LD A,(CCODE)
LD C,A
PUSH HL
PUSH DE
PUSH BC
CALL RDFLP
POP BC
POP DE
POP HL
AND 10011100B
RET Z
AND 00010000b	;record not found then seek
JR NZ,..TRY1	;restore first
LD A,(FEHZA)
INC A
LD (FEHZA),A
CP 5
JR C,..SK11
CP 10
JR C,..TRY1
LD A,0FFH
OR A
SCF
RET
;
..WRTEX:
LD A,(CCODE)
LD C,A
PUSH HL
PUSH DE
PUSH BC
CALL WRFLP
POP BC
POP DE
POP HL
AND 11111100B
RET Z
AND 00010000b	;3.2 seek err on RNF half errcount
JR NZ,..TRY1	;restore seek first
LD A,(FEHZA)
INC A
LD (FEHZA),A
CP 4
JP C,..TRY1	;bei write gleich rstore
LD A,0FFH	;r/o error
OR A
SCF
RET
;
;
SELDUM:		;WIE SEEK AUSFUEHREN
PUSH HL
PUSH DE
PUSH BC
CALL SEEK	;IGNORE FEHLER
POP BC
POP DE
POP HL
RET
RET
;

;

MINEXX:
LD A,(DRVCODE)
LD C,A		;code of drive 0..7  bit 0=side sel
;
LD A,(MDRVAT)
CP C		;GLEICHE DRIVE
JP Z,..MSK2	;WEITER DANN
 		; hier aber immer mit abb
		; end rev 821127
PUSH HL
PUSH BC
LD HL,MDRVTAB	;TABELLEN INDEX BERECHNEN
LD A,(MDRVAT)
CP 0FFH		;UNDEF
JR Z,MNOD
RRCA		;
AND 00000011b
LD C,A
LD B,0
ADD HL,BC
IN A,(31H)	;ALTER TRACK
LD (HL),A	;RETTEN VOR RSTORE AUSFUEHRUNG NOETIG ABER
MNOD:		;UNDEF NICHT ZURUECK
POP BC
POP HL		;ERSTMAL ALTE DRIVE RETTEN
PUSH HL
PUSH BC
LD HL,MDRVTAB
LD A,C
RRCA		;
AND 00000011b
LD C,A
LD B,0		;IN C NEUE DRIVE
ADD HL,BC
LD A,(HL)
OUT (31H),A	;NEUER TRACK HOLEN
POP BC
POP HL
LD A,C
LD (MDRVAT),A	;NUN NEUE DRIVE
PUSH AF		;NEU BUG 810917
PUSH BC		;BETREFF HEADLOAD
PUSH BC		;rev 821127
LD BC,1000*3/12	;1MS  BEI 6MHZ AUCH
..MLPPD:
DEC BC
LD A,B
OR C
JP NZ,..MLPPD	;WARTEN TUNNELERASE COMPLETED
POP BC		;rev 82112
LD A,(CCODE)	;rev 830318 vorher falscher code
		;NEUE DRIVE CODED 1,2,4,8
AND 0FH		;AUSGEBEN
OUT (34H),A	;OHNE AUTOWAIT
;
LD BC,2917	;ca 35 MS WARTEN UNKRIT. (10MS..35MS)
..MLP4:		;WICHTIG ABER BEI SCHREIBEN NACH LESEN
DEC BC		;FALLS DRIVES HEADLOAD BESITZEN
LD A,B
OR C
JP NZ,..MLP4	;DA SONST SETTLE NICHT OK
POP BC
POP AF		;END 810917
		;rev 3.2 830205
JR ..MSKKK1	;bei laufwerkswechsel kann head load
		;down sein aber dennoch drive not ready
		;daher immer dummy seek ausfuehren
..MSK2:
		;rev 3.2 ohne PIO
IN A,(34H)	;wenn head load vorliegt kann
AND 20H		;ready nicht ungueltig sein wegen reihenfolge
JR NZ,..MOV	;fertig dann
	
..MSKKK1:	;warte schleife seek solange bis status
		;ein ready angibt

LD A,(CCODE)
LD C,A		;drive code internal
CALL MSELDUM	;SELEKT DUMMY AUSFUEHREN mit seek

IN A,(30H)	;bit 7 entscheidet
AND 80H
JR NZ,..MSKKK1	;bis ausgefuehrt
		;drive wird nicht not ready ohne
		;das headload weggeht im normal fall
		;da nur MOTOR OFF automatik hier
		;wesentlich ist
..MOV:

IN A,(31H)	;TRACK HOLEN
CP 0FFH
JR Z,..MTRY1	;UNDEF DANN RESTORE
CP D		;GLEICH DANN WEITER
JP Z,..MSK11	;KEIN SUCHEN NOETIG
		;SUCHEN NOETIG
..MTRY:
LD A,(CCODE)
LD C,A
PUSH HL
PUSH DE
PUSH BC
CALL MSEEK
POP BC
POP DE
POP HL
AND 10010000B
JR Z,..MSK11	;OK WEITER
..MTRY1:		;EINGANG BEI LESEFEHLER UND SCHRBFEHLER
LD A,(CCODE)
LD C,A
		;FEHLER AUFGETRETEN
		;RSTORE AUSFUEHREN
PUSH HL
PUSH DE
PUSH BC
CALL MRSTORE
POP BC
POP DE
POP HL
LD A,(FEHZA)	;FEHLER COUNT
INC A
LD (FEHZA),A
CP 10
JR C,..MTRY
LD A,0FFH
OR A
SCF
RET		;FEHLER



..MSK11:	;KEIN SEEK WAR NOETIG
LD A,B		;BEFEHL
CP 2
JP Z,..MWRTEX
LD A,(CCODE)
LD C,A
PUSH HL
PUSH DE
PUSH BC
CALL MRDFLP
POP BC
POP DE
POP HL
AND 10011100B
RET Z
AND 00010000b	;3.2 rstore seek
JR NZ,..MTRY1
LD A,(FEHZA)
INC A
LD (FEHZA),A
CP 5
JR C,..MSK11
CP 10
JR C,..MTRY1
LD A,0FFH
OR A
SCF
RET


;
..MWRTEX:
LD A,(CCODE)
LD C,A
PUSH HL
PUSH DE
PUSH BC
CALL MWRFLP
POP BC
POP DE
POP HL
AND 11111100B
RET Z
AND 00010000b	;3.2 restore seek
JR NZ,..MTRY1	;on seek error RNF no double count here
LD A,(FEHZA)
INC A
LD (FEHZA),A
CP 4
JP C,..MTRY1	;bei write gleich rstore
LD A,0FFH	;r/o error
OR A
SCF
RET
;
;
MSELDUM:	;WIE SEEK AUSFUEHREN
PUSH HL
PUSH DE
PUSH BC
CALL MSEEK	;IGNORE FEHLER
POP BC
POP DE
POP HL
RET


LOC10:	DEFB 0,0,0	;SPRUNG AUSTAUSCHSTELLE
DRVCODE: DEFB 0		;temp phys drive code
CCODE:  DEFB 0		;code fuer ausgabeport
MAXSTP:	DEFB 0
MINSTP: DEFB 0
MSIDE:  DEFB 0		;flags fuer adressierung etc
FEHZA:	DEFB 0
DRVAT:	DEFB 0FFH	;0..7 STD WERT ZWSPEICHER
			;DANN IST RSTORE NOETIG

DRVTAB:	DEFB 0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH	;TRACKWERTE FUER DRIVES 1...8
MDRVAT:	DEFB 0FFH	;1...8 STD WERT ZWSPEICHER
			;DANN IST RSTORE NOETIG

MDRVTAB: DEFB 0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH	;TRACKWERTE FUER DRIVES 1...8
;

;
FREEMEM 	EQU	$	;dynamischer Platz fuer Buffer etc.

;*******************************************************
;* Bereich kann geloescht werden unter CP/M            *
;* um Platz fuer Puffer etc zu bieten                  *
;*******************************************************
;
;
MSG:
DEFB 0DH,0AH
DEFB 7 ; BELL
DEFM " MC01-MONITOR EPR-START"
DEFM " V3.4 ,AL = L,"
DEFM " RDK / HE "
DEFM 0DH,0AH,0
MSGL	EQU	$-MSG


BEGIN1:		;nur einmal verwendet
;    ------ INIT ------
LD C,SIOASTS
LD B,8
LD HL,TABSIO
OTIR
LD C,SIOBSTS
LD B,8
LD HL,TABSIB
OTIR
JR SKSKL
TABSIO:
DEFB 1,0
DEFB 3,11100001B	; -CTS UND -DCD ENABLE rev 3.4 term1
DEFB 4,01001100B
DEFB 5,11101010B	;dtr rts +12V bedeutet ready rev 3.4
;
TABSIB:			;-CTS UND -DCD ENABLE
DEFB 1,0
DEFB 3,11100001B
DEFB 4,01001100B
DEFB 5,11101010B	;dtr rts +12V bedeutet ready rev 3.4
;
SKSKL:

; pio nicht mehr noetig mit 3.2
;
LD A,(7000H)	;bank Selekt umschalten
;

;entf{llt, damit AL = L automatisch
;XOR A		;alles auf Console schalten
;LD (IOBYT),A

;    ------ END INIT -------

LD SP,AHEAD-4
JP MEMSIZ+1
DEFW AHEAD
AHEAD:
LD SP,HL
EX DE,HL
LD BC,ENDX-EXIT
LD HL,EXIT
LDIR
EX DE,HL
LD BC,-5FH
ADD HL,BC
PUSH HL
LD HL,0
LD B,10	;REGISTER
STKIT:
PUSH HL
DJNZ STKIT
HELLO:
LD C,1AH
CALL CO
LD B,MSGL
CALL TOM1
;	Haupt eingabeschleife
START:
LD DE,START
PUSH  DE
CALL CRLF
LD C,'>'
CALL CO
;
STAR0:
CALL TI
AND 7FH
JR Z,STAR0
SUB 'A'
RET M
CP 'Z'-'A'+1
RET NC
ADD A,A
LD HL,TBL
ADD A,L
LD L,A
LD A,H
ADC A,0
LD H,A
LD A,(HL)
INC HL
LD H,(HL)
LD L,A
LD C,2
JP (HL)		;EXEC

; Befehlstabelle
; enthaelt alle Monitorbefehle

TBL:
DEFW ASSIGN
DEFW BYE
DEFW COMP
DEFW DISP
DEFW EOF
DEFW FILL
DEFW GOTO
DEFW HEXN
DEFW BOOT1
DEFW TEST
DEFW KEXEC
DEFW LOAD
DEFW MOVE
DEFW NULL
DEFW OEXEC
DEFW PUTA
DEFW QUERY
DEFW READ
DEFW SUBS
DEFW TYPE
DEFW UNLO
DEFW VERIFY
DEFW WRITE
DEFW XAM
DEFW WHERE
DEFW SIZE

;
; BOOT FLOPPY HARD/SOFT/MINI
FLPMSG:
DEFB 0DH,0AH
DEFM "EPROM-Boot = 0, 8-Zoll = 1, 5 1/4 = 2 :"
FLPL	EQU $-FLPMSG
;
BOOT1:
CALL INIFLP	;vektoren etc definieren
LD HL,FLPMSG	;FALLS DA
LD B,FLPL	;Meldung ausgeben
CALL TOM	;dann Antwort abwarten
CALL CI
AND 7FH		;ohne Paritaet
LD C,A
CALL CO
CP "I"		;I-Vektor fuer Benutzerbefehl
JP Z,IEXEC
cp 0		;Eprom-Boot
jp z,eprboo
CP "2"		;Mini Laufwerk Boot
JR Z,M2EX
CP "1"		;Maxi Laufwerk Boot
JP Z,MEXC
JP ERROR
;
MEXC:
CALL FLPSET
CALL MAXI	;SINGLE DENSE BOOT 128 BYTES
JR M3EX
;
M2EX:
CALL FLPSET
CALL MINI	;SINGLE DENSE BOOT 128 BYTES 
M3EX:
		;AUCH BEI DOUBLE DENSE MINIFLP
		;DA TRK0 IMMER SINGLE DENSE IST
JP C,ERROR	;FEHLER
JP 80H		;UND STARTEN
;
;
FLPSET:
LD HL,80H	;BOOTEN
LD D,0		;TRK 0
LD E,1		;SEKTOR 1
LD B,1		;LESEN
LD C,0		;DRIVE 0
RET


;********** Eprom-Boot ***********
losepr	equ	6H	;Inside Sektor
hisepr	equ	2H	;Sektor-Selekt
traepr	equ	0H	;Track-Selekt
eprfl	equ	5H	;Daten

EPRBOO:	
	LD	HL,0D400H	;CP/M-Beginn
	LD	D,38H/2		;28 * 256 Bytes = 1C00H
	LD	A,0		;Beginn bei 0 
	OUT	(LOSEPR),A	;Z{hler setzen
	OUT	(HISEPR),A
	OUT	(TRAEPR),A
	LD	C,EPRFL		;PORT zum Daten lesen
EPRSEC:	
	LD	B,0
	INIR		;IN (HL),(C);INC HL, DEC B <> 0
	DEC	D		;Z{hler f}r Blockanzahl
	JP	NZ,EPRSEC
	JP	0EA00H		;BIOS-Kaltstart



; IOBYTE ASSIGNE
; 000000XX CONSOLE
; 0000XX00 READER
; 00XX0000 PUNCH
; XX000000 LISTER

; 00= TELETYPE CONS

ASSIGN:		;ZUWEISUNG
CALL TI
LD HL,LTBL
LD BC,400H
LD DE,5
AREP0:
CP (HL)
JR Z,AREP1
ADD HL,DE
INC C
DJNZ AREP0
JR LXERR
AREP1:
LD E,C
AREP22:
CALL TI
CP "="
JR NZ,AREP22
CALL TI
LD BC,400H
AREP33:
INC HL
CP (HL)
JR Z,LXA4
INC C
DJNZ AREP33
LXERR:
JP ERROR
LXA4:
LD A,3
INC E
LXA5:
DEC E
JR Z,LXA6
SLA  C
SLA  C
RLA
RLA
JR LXA5
LXA6:
CPL
LD D,A
LXA7:
CALL PCHK
JR NC,LXA7
LD A,(IOBYT)
AND D
OR C
LD C,A
JP IOSET
;
; BYE COMMAND

BYE:
CALL CRLF
LXBY:
CALL KI		;In HEX Dump 1E 
CP 0EH		;CRTL N ist 0eh
JR NZ,LXBY	;gaendert gegen MC-Vers
POP DE
JP HELLO

;
;
; PUT ASCII INTO MEM
; Damit ist es moeglich Texte direkt in den Speicher
; einzugeben

PUTA:
CALL EXPR1
CALL CRLF
POP HL
AREP11:
CALL KI
CP 4		;beenden der Eingabe CTRL-D
JP Z,LFADR
CP "_"		;rueckwaerts schreiten
JR Z,AREP34
LD (HL),A
LD C,A
INC HL
AREP23:
CALL CO
JR AREP11
AREP34:
DEC HL
LD C,(HL)
JR AREP23
;
; COMPARE BIN
; Vergleich eines Speicherbereichs
; mit dem Reader

COMP:
CALL EXLF
LXC:
CALL RIFF
CP (HL)
CALL NZ,CERR
CALL HILOX
JR LXC

; M AUSGABE

CERR:
LD B,A
CALL HLSP
LD A,(HL)
CALL LBYTE
CALL BLK
LD A,B
CALL LBYTE
JP CRLF

; DISPLAY
; Ausgabe eines Speicherbereichs

DISP:
CALL EXLF
LXD0:
CALL LFADR
LXD1:
CALL BLK
LD A,(HL)
CALL LBYTE
CALL HILOX
LD A,L
AND 0FH
JR NZ,LXD1
JR LXD0
;
; EOF AUSGABE
; fuer Punch , Intel-Hex Ende ausgeben

EOF:
CALL EXPR1
CALL PEOL
LD C,':'
CALL POO
XOR A
CALL PBYTE
POP HL
CALL PADR
LD HL,0
CALL PADR
JP NULL

; FILL
; Einen Speicherbereich mit einem
; Wert fuellen

FILL:
CALL EXPR3
LXF:
LD (HL),C
CALL HILO
JR NC,LXF
POP DE
JP START

;

; EXEC OTHER PRGS
; Start eines Anwenderprogramms
; mit Break-Points

GOTO:
CALL PCHK
JR C,LXG3
JR Z,LXG0
CALL EXF
POP DE
LD HL,PLOC
ADD HL,SP
LD (HL),D
DEC HL
LD (HL),E
LD A,B
CP 0DH
JR Z,LXG3
LXG0:
LD D,2
LD HL,TLOC
ADD HL,SP
LXG1:
PUSH HL
CALL EXPR1
LD E,B
POP BC
POP HL
LD A,B
OR C
JR Z,LXG2
LD (HL),C
INC HL
LD (HL),B
INC HL
LD A,(BC)
LD (HL),A
INC HL
LD A,0FFH
LD (BC),A
LXG2:
LD A,E
CP 0DH
JR Z,LXG2A
DEC D
JR NZ,LXG1
LXG2A:	
LD A,0C3H	;Rueckkehr mit RST7 vorbereiten
LD (RST7),A
LD HL,TRAP
LD (RST7+1),HL
LXG3:
CALL CRLF
POP DE
LD HL,22
ADD HL,SP
JP (HL)		;und Programm starten


;
;
; TEST
; Schnelltest fuer den Speicher
; FAST Complement Test
;
TEST:
CALL EXLF
LXT11:
LD A,(HL)
LD B,A
CPL
LD (HL),A
XOR (HL)
JR Z,LXT2
PUSH DE
LD D,B
LD E,A
CALL HLSP
CALL BITS
CALL CRLF
LD B,D
POP DE
LXT2:
LD (HL),B
CALL HILOX
JR LXT11
;
; LDE

; Transport eines Speicherbereichs
; in einen anderen

MOVE:
CALL EXPR3
LXM:
LD A,(HL)
LD (BC),A
INC BC
CALL HILOX
JR LXM


; READ ROUTINE
; einlesen von Intel-Hex oder TDL-Daten

;
READ:
CALL EXPR1
LD A,B
SUB 0DH
LD B,A
LD C,A
POP DE
JR Z,LXR00
CALL EXPR1
POP BC
LXR00:
EX DE,HL
EXX
CALL CRLF
LOD0:
CALL RIX
SUB ':'
LD B,A
AND 0FEH
JR NZ,LOD0
LD D,A
CALL SBYTE
LD E,A
CALL SBYTE
PUSH AF
CALL SBYTE
EXX
POP DE
LD E,A
PUSH BC
PUSH DE
PUSH HL
ADD HL,DE
EX (SP),HL
POP IX
EXX
POP HL
CALL SBYTE
DEC A
LD A,B
POP BC
JR NZ,AREPA
ADD HL,BC
ADD IX,BC
AREPA:
INC E
DEC E
JR Z,DONE
DEC A
JR Z,LODR
LXL11:
CALL SBYTE
CALL STORE
JR NZ,LXL11
LOD4:
CALL SBYTE
JR Z,LOD0
ERR2:
PUSH IX
POP HL
CALL LADR
JP ERROR
DONE:
LD A,H
OR  L
RET Z
EX DE,HL
LD HL,PLOC
ADD HL,SP
LD (HL),D
DEC HL
LD (HL),E
RET
LODR:
LD L,1
LXL12:
CALL LOD03
JR C,LXL33
LXL5:
CALL STORE
JR NZ,LXL12
JR LOD4
LXL33:
LD C,A
CALL LOD03
LD B,A
EXX
PUSH BC
EXX 
EX (SP),HL
ADD HL,BC
LD A,L
CALL STORE
LD A,H
POP HL
JR LXL5
LOD03:
DEC L
JR NZ,LXL01
CALL SBYTE
DEC E
LD H,A
LD L,8
LXL01:
CALL SBYTE
SLA H
RET

SBYTE:
PUSH BC
CALL RIBBLE
RLCA
RLCA
RLCA
RLCA
LD C,A
CALL RIBBLE
OR C
LD C,A
ADD A,D
LD D,A
LD  A,C
POP BC
RET

STORE:
LD (IX+0),A
CP (IX+0)
JR NZ,ERR2
INC IX
DEC E
RET


; SUBST
; Interaktive Eingabe von Hex-Werten

SUBS:
CALL EXPR1
POP HL
LXS0:
LD A,(HL)
CALL LBYTE
CALL COPCK
RET C
JR Z,LXS1
CP '_'
JR Z,LXS2
PUSH HL
CALL EXF
POP DE
POP HL
LD (HL),E
LD A,B
CP 0DH
RET Z
LXS1:
INC HL
LXS3:
LD A,L
AND 7
CALL Z,LFADR
JR LXS0
LXS2:
DEC HL
JR LXS3

;
;
;  TYPE
; Ausgabe von Speicherbereichen in lesbarer
; Form
;
 
TYPE:
CALL EXLF
LXT0:
CALL LFADR
LD B,32+32
LXT1:
LD A,(HL)
AND 7FH
CP ' '
JR NC,LXT3
LXT22:
LD A,'.'
LXT3:
CP 7CH
JR NC,LXT22
LD C,A
CALL CO
CALL HILOX
DJNZ LXT1
JR LXT0

;

;

; SEARCH
; Suchen von Werten im Speicher

;
WHERE:
LD D,0
LXW00:
CALL EXPR1
POP HL
LD H,L
PUSH HL
INC  SP
INC D
LD A,B
SUB 0DH
JR NZ,LXW00
LD B,A
LD C,A
LD H,A
LD L,D
DEC L
ADD HL,SP
PUSH HL
PUSH BC
FINDC:
PUSH BC
CALL CRLF
POP BC
FIND:
POP HL
POP IX
LD E,D
LD A,(IX+0)
CPIR
JP PO,DONE2
PUSH IX
PUSH HL
FOUND:
DEC E
JR Z,TELL
LD A,(IX-1)
CP (HL)
JR NZ,FIND
INC HL
DEC IX
JR FOUND
TELL:
POP HL
PUSH HL
DEC HL
PUSH BC
CALL LADR
POP BC
JR FINDC
DONE2:
INC SP
DEC E
JR NZ,DONE2
RET
;
;
WRITE:
CALL EXLF
LXW0:
CALL PEOL
LD BC,':'
CALL POO
PUSH DE
PUSH HL
LXW1:
INC B
CALL HILO
JR C,LXW4
LD A,24
SUB B
JR NZ,LXW1
POP HL
CALL LXW2
POP DE
JR LXW0
LXW2:
LD D,A
LD A,B
CALL PBYTE
CALL PADR
XOR  A
CALL PBYTE
LXW3:
LD A,(HL)
CALL PBYTE
INC HL
DJNZ LXW3
XOR A
SUB D
JP PBYTE
LXW4:
POP HL
POP DE
XOR  A
JR LXW2
;
;
; XAM  USER REG
;
XAM:
CALL TI
LD HL,ACTBL
CP 0DH
JR Z,LXX6
CP "'"
JR NZ,LXX0
LD HL,PRMTB
CALL TI
CP 0DH
JR Z,LXX6
LXX0:
CP (HL)
JR Z,LXX1
BIT 7,(HL)
JP NZ,ERROR
INC HL
INC HL
JR LXX0
LXX1:
CALL BLK
LXX2:
INC HL
LD A,(HL)
LD B,A
AND 3FH
EX DE,HL
LD L,A
LD H,0
ADD HL,SP
EX DE,HL
INC HL
LD A,(DE)
CALL LBYTE
BIT 7,B
JR Z,LXX3
DEC DE
LD A,(DE)
CALL LBYTE
LXX3:
CALL COPCK
RET C
JR Z,LXX5
PUSH HL
PUSH BC
CALL EXF
POP HL
POP AF
PUSH BC
PUSH AF
LD A,L
LD (DE),A
POP BC
BIT 7,B
JR Z,LXX4
INC DE
LD A,H
LD (DE),A
LXX4:
POP BC
POP HL
LD A,B
CP 0DH
RET Z
LXX5:
BIT 7,(HL)
RET NZ
JR LXX2
LXX6:
CALL CRLF
LXX7:
CALL BLK
LD A,(HL)
INC HL
OR A
RET M
LD C,A
CALL CO
LD C,"="
CALL CO
LD A,(HL)
LD B,A
AND 3FH
INC HL
EX DE,HL
LD L,A
LD H,0
ADD HL,SP
EX DE,HL
BIT 6,B
JR NZ,LXX9
LD A,(DE)
CALL LBYTE
BIT 7,B
JR Z,LXX7
DEC DE
LD A,(DE)
LXX8:
CALL LBYTE
JR LXX7
LXX9:
PUSH HL
LD A,(DE)
LD H,A
DEC DE
LD A,(DE)
LD L,A
LD A,(HL)
POP HL
JR LXX8
;
; MESSAGE OUTPUT ROUTINE

TOM1:
LD HL,MSG

TOM:
LD C,(HL)
INC HL
CALL CO
DJNZ TOM
CALL CSTS
OR A
RET Z
;
;IF CTRL C ABORT

CCHK:
CALL KI
CP 3
RET NZ
;

;
; ERROR
;
ERROR:
CALL MEMSIZ
LD DE,-22
ADD HL,DE
LD SP,HL
LD C,7
CALL CO
LD C,'*'
CALL CO
JP START

;
; READER INPUT
; ABORT ON CARRY
; COMPARE WITH D
RIFF:
CALL RI
JR C,ERROR
CP D
RET
;
;
; SEARCH MEM

SIZE:
CALL MEMSIZ
LD BC,ENDX-EXIT
ADD HL,BC
;
;
LFADR:
CALL CRLF
;
HLSP:
CALL LADR
;
BLK:
LD C,' '
JP CO

;
;
;

PEOL:
LD C,0DH
CALL POO
LD C,0AH
JP POO
;
;
; UNLOAD ROUTINE
; Ausgabe eines Speicherbereichs binaer


UNLO:
CALL EXLF
CALL LEAD
CALL MARK
LXO:
LD C,(HL)
CALL POO
CALL HILO
JR NC,LXO
CALL MARK
; GOTO NULL
; NULL PUNCH
;
NULL:
CALL LEAD
;
RET
;

CONV:
AND 0FH
ADD A,90H
DAA 
ADC A,40H
DAA
LD C,A	;HEX TO ASC
RET
;
EXLF:
CALL EXPR
POP DE
POP HL
;
;
CRLF:
PUSH HL
LD B,2
CALL TOM1
POP HL
RET
;

; Eingabe von Hex Wertes von der Console
;
;
EXPR3:
INC C
CALL EXPR
CALL CRLF
POP BC
POP DE
POP HL
RET
;

;
EXPR1:
LD C,1
;
;
EXPR:
LD HL,0
EX0:
CALL TI
EX1:
LD B,A
CALL NIBBLE
JR C,LXEX2
ADD HL,HL
ADD HL,HL
ADD HL,HL
ADD HL,HL
OR L
LD L,A
JR EX0
LXEX2:
EX (SP),HL
PUSH HL
LD A,B
CALL QCHK
JR NC,LXEX3
DEC  C
RET Z
LXEX3:
JP NZ,ERROR
DEC C
JR NZ,EXPR
RET
EXF:
LD C,1
LD HL,0
JP EX1
;
;
HILOX:
CALL HILO
RET NC
POP DE
RET
;
HILO:
INC HL
LD A,H
OR L
SCF
RET Z
LD A,E
SUB L
LD  A,D
SBC A,H
RET
;
;
; HEX MATH
;
HEXN:
CALL EXLF
PUSH HL
ADD HL,DE
CALL HLSP
POP HL
OR   A
SBC HL,DE
LADR:
LD A,H
CALL LBYTE
LD A,L
LBYTE:
PUSH AF
RRCA
RRCA
RRCA
RRCA
CALL LXR22
POP AF
LXR22:
CALL CONV
JP CO
;
;
MARK:
LD BC,8FFH
JR LEO
;
;
LEAD:
LD BC,4800H
LEO:
CALL POO
DJNZ  LEO
RET
;


;
RIBBLE:
CALL RIX
NIBBLE:
SUB '0'
RET C
CP 'G'-'0'
CCF
RET C
CP 10
CCF
RET NC
SUB 'A'-'9'-1
CP 0AH
RET
;
;
PADR:
LD A,H
CALL PBYTE
LD A,L
;
PBYTE:
PUSH AF
RRCA
RRCA
RRCA
RRCA
CALL CONV
CALL POO
POP AF
PUSH AF
CALL CONV
CALL POO
POP AF
ADD A,D
LD D,A
RET
;
;
COPCK:
LD C,'-'
CALL CO
PCHK:
CALL TI
QCHK:
CP ' '
RET Z
CP ','
RET Z
CP 0DH
SCF
RET Z
CCF
RET
;
;
;
RIX:
CALL RIFF
AND 7FH
RET
;
; laden von Binaerdaten 
; startkennung ist eine Gruppe von 0FFh
; Werten
;
LOAD:
CALL EXPR1
POP HL
CALL CRLF
LD D,0FFH
LXL0:
LD B,4
LXLL1:
CALL RIFF
JR NZ,LXL0
DJNZ LXLL1
LXL2:
CALL RIFF
JR Z,LXL2
LD (HL),A
LD A,7
;+++ OUT TTY +++
LXL3:
INC HL
CALL RIFF
JR Z,LXEL
LD (HL),A
JR LXL3
LXEL:
LD E,1
LXEL0:
CALL RIFF
JR NZ,LXEL1
INC E
LD A,7	;MAX +++
CP E
JR NZ,LXEL0
JP LADR
LXEL1:
LD (HL),D
INC HL
DEC  E
JR NZ,LXEL1
LD (HL),A
JR  LXL3
;
;
; Eingang nach einem Break-Point
;
RESTART:

PUSH HL
PUSH DE
PUSH BC
PUSH AF
CALL MEMSIZ
EX DE,HL
LD HL,10
ADD HL,SP
LD B,4
EX DE,HL
LXR0:
DEC HL
LD (HL),D
DEC HL
LD (HL),E
POP DE
DJNZ LXR0
POP BC
DEC BC
LD SP,HL
LD HL,TLOCX
ADD HL,SP
LD A,(HL)
SUB C
INC HL
JR NZ,LXR1
LD A,(HL)
SUB B
JR Z,LXR3
LXR1:
INC HL
INC HL
LD  A,(HL)
SUB C
JR NZ,LXR2
INC HL
LD  A,(HL)
SUB B
JR Z,LXR3
LXR2:
INC BC
LXR3:
LD HL,LLOCX
ADD HL,SP
LD (HL),E
INC HL
LD (HL),D
INC HL
INC HL
LD (HL),C
INC HL
LD (HL),B
PUSH BC
LD C,'@'
CALL CO
POP HL
CALL LADR
LD HL,TLOCX
ADD HL,SP
LD BC,200H
LXR4:
LD E,(HL)
LD (HL),C
INC HL
LD D,(HL)
LD (HL),C
INC HL
LD A,E
OR D
JR Z,LXR5
LD A,(HL)
LD (DE),A
LXR5:
INC HL
DJNZ LXR4
EX AF,AF'
EXX
PUSH HL
PUSH DE
PUSH BC
PUSH AF
PUSH IX
PUSH IY
LD A,I
LD B,A
LD A,R
LD C,A
PUSH BC
JP START
;
;
;
KI:
CALL CI
AND 7FH
RET
;
;
TI:
CALL KI
RET Z
INC A
RET M
DEC A
CP 0DH
RET Z
CP 'N'
RET Z
CP 'n'
JR Z,LXT
PUSH BC
LD C,A
CALL CO
LD A,C
POP BC
CP 'A'-1
RET C
CP 'z'+1
RET NC
LXT:
AND 05FH
RET

;
; Ein-und Ausgabe auf Ports
;
;
QUERY:
CALL TI
CP 'O'
JR Z,QUO
CP 'I'
JP NZ,ERROR
CALL EXPR1
POP BC
IN E,(C)
BITS:
LD B,8
CALL BLK
LXQ2:
SLA E
LD A,'0' SHR 1
ADC A,A
LD C,A
CALL CO
DJNZ LXQ2
RET
QUO:
CALL EXPR
POP DE
POP BC
OUT (C),E
RET
;
; Vergleich von Speicherbereichen
;
; VERIFY
VERIFY:
CALL EXPR3
VERI0:
LD A,(BC)
CP (HL)
JR Z,LXBBN
PUSH BC
CALL CERR
POP BC
LXBBN:
INC BC
CALL HILOX
JR VERI0
;
; IO LOOKUP TABLE
LTBL:
DEFB 'C'
DEFB 'T'
DEFB 'V'
DEFB 'B'
DEFB 'U'

DEFB 'R'
DEFB 'T'
DEFB 'P'
DEFB 'C'
DEFB 'U'

DEFB 'P'
DEFB 'T'
DEFB 'P'
DEFB 'C'
DEFB 'U'

DEFB 'L'
DEFB 'T'
DEFB 'V'
DEFB 'L'
DEFB 'U'

EXIT:
POP BC
LD A,C
LD R,A
LD A,B
LD I,A
POP IY
POP IX
POP AF
POP BC
POP DE
POP HL
EX AF,AF'
EXX
POP DE
POP BC
POP AF
POP HL
LD SP,HL
NOP
LD HL,0
JP 0

DEFW 0
DEFB 0
DEFW 0
DEFB 0		;TRAP AREA

ENDX:
ALOC	EQU	15H
BLOC	EQU	13H
CLOC	EQU	12H
DLOC	EQU	11H
ELOC	EQU	10H
FLOC	EQU	14H
HLOC	EQU	31H
LLOC	EQU	30H
PLOC	EQU	34H
SLOC	EQU	17H
TLOC	EQU	35H
TLOCX	EQU	25H
LLOCX	EQU	20H

APLOC	EQU	9
BPLOC	EQU	0BH
CPLOC	EQU	0AH
DPLOC	EQU	0DH
EPLOC	EQU	0CH
FPLOC	EQU	8
HPLOC	EQU	0FH
LPLOC	EQU	0EH
XLOC	EQU	7
YLOC	EQU	5
RLOC	EQU	2
ILOC	EQU	3


; TABELLE
ACTBL:
DEFB 'A',ALOC OR 0
DEFB 'B',BLOC OR 0
DEFB 'C',CLOC OR 0
DEFB 'D',DLOC OR 0
DEFB 'E',ELOC OR 0
DEFB 'F',FLOC OR 0
DEFB 'H',HLOC OR 0
DEFB 'L',LLOC OR 0
DEFB 'M',HLOC OR 0C0H
DEFB 'P',PLOC OR 080H
DEFB 'S',SLOC OR 080H
DEFB 'I',ILOC OR 0

DEFB 0C1H

PRMTB:
DEFB 'A',APLOC OR 0
DEFB 'B',BPLOC OR 0
DEFB 'C',CPLOC OR 0
DEFB 'D',DPLOC OR 0
DEFB 'E',EPLOC OR 0
DEFB 'F',FPLOC OR 0
DEFB 'H',HPLOC OR 0
DEFB 'L',LPLOC OR 0
DEFB 'M',HPLOC OR 0C0H
DEFB 'X',XLOC  OR 080H
DEFB 'Y',YLOC  OR 080H
DEFB 'R',RLOC  OR 0
DEFB 0C1H
;
;
;
LASTMON:	DEFB 0	;LAST STORAGE

.DEPHASE
; 
;
END 
